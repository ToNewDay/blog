[{"route":"/docs/react/INTRO.html","content":" React使用ReactHooks的无状态组件，在每次渲染时，包括组件内的函数，都会保留所有state，props在执行时刻的值，这一点和class版本的组件具有很大的差异，class版本会取到最新值。 typescriptimportReact, Component from react classOldAppextendsComponent constructor props super props this.state count 1 testOnclick setTimeout console.log this.state.count ,3000 render return div div oldApp div div this.state.count div buttononClick this.setState count this.state.count 1 add button buttononClick this.testOnclick show button div exportdefaultOldApp 多次点击add，交错点击show，console里输出最新状态的countn次。 typescriptfunctionApp const count,setCount useState name 1 functionhandleAlertClick setTimeout alert count.name ,3000 return divclassName App OldApp p count.name p buttononClick setCount name count.name 1 add button buttononClick handleAlertClick alert button div exportdefaultApp 多次点击add，交错点击alert，console多次出现被调用当时的值。class版本可以使用闭包修复，实际Hooks依赖JavaScript闭包。如果希望无状态组件获取到最新值，想class这样的表现，可以使用 useRef typescriptfunctionApp const count,setCount useState num 1 constlastCount useRef count functionhandleAlertClick lastCount.current count setTimeout console.log lastCount.current.num ,3000 return divclassName App p count.num p buttononClick setCount num count.num 1 add button buttononClick handleAlertClick alert button div ReactHooks useMemo 只有在某个依赖项改变时才会重新计算 typescriptconstmemoizedValue useMemo computeExpensiveValue a,b , a,b useCallback 把内联函数以及依赖数组作为参数传入，将返回回调函数的memoized版本。 typescriptconstmemoizedCallback useCallback doSomething a,b , a,b , 直接定义的函数，在每次渲染时其实都会变化，这样的函数无法作为其他Hook的依赖存在，通过useCallback定义的函数，可作为其他hooks的依赖存在。当有多个useEffect，我们希望抽象出useEffect相同部分的逻辑，这部分逻辑依赖于props或者state时，可以考虑使用useCallback。 useContext 上下文 typescriptimportReactfrom react exportdefaultReact.createContext null jsximportReact, useEffect,useState,useRef,useReducer,useContext from react import . App.css importTestfrom . Test importToDoContextfrom . ToDoContext functionApp const count,dispatch useReducer reducer, num 1 functionreducer state,action switch action.type case add return ...state,num state.num 1 return ToDoContext.Providervalue count,dispatch Test Test ToDoContext.Provider exportdefaultApp jsximportReact, useContext from react importToDoContextfrom . ToDoContext functionTest const count,dispatch useContext ToDoContext return div count.num div exportdefaultTest 上下文用于解决React层层传递数据的问题，被包裹的子组件可以获取到全局数据，通常全局状态树会使用到上下文。 useEffect 在render之后执行的的方法，可以理解为 componentDidMount 或者 componentDidUpdate 生命周期经常完成的操作，但是不一样的是，我们可以通过传递依赖的形式，确保代码仅在依赖变化时执行，这点我们之前使用 shouldComponentUpdate 进行 props 的对比类似。 useRef 使用useRef创建的对象和之间创建的对象的不同之处在于，useRef返回的对象，在每次使用时会拿到最新值，而不是当次渲染值。 useReducer 当改变状态的逻辑很复杂时，我们通常使用useReducer来实现，而其他地方只需要dispatch相应的type不需要关心如何改变。同时结合useContext我们可以做到统一的状态树管理 useEffect详解useEffect用来处理会有副作用的操作，比如之前我们在生命周期函数中常常使用的获取数据操作。 typescriptuseEffect async constresult awaitaxios https hn.algolia.com api v1 search query redux , setData result.data 但是这样并不理想，因为不经在组件加载时会执行，在组件更新时也会执行，因此，对于只需要在加载阶段执行的操作，我们通常给予一个空依赖。 typescriptuseEffect async constresult awaitaxios https hn.algolia.com api v1 search query redux , setData result.data , 如此在第一次执行之后，useEffect不会再执行，因为依赖未变化 为空 。但是这样依然不完美，useEffect并不希望函数有返回，而异步函数实际上会返回一个 AsyncFunction ，会报警告，因此我们可以这样优化。 typescriptuseEffect constfetchData async constresult awaitaxios https hn.algolia.com api v1 search query redux , setData result.data fetchData , 以上操作实际使用effects模拟了传统的生命周期函数 ComponentDidMount 。而实际上我们应该用不同的眼光来看待 useEffect 。例如常见的查询获取数据操作 typescriptconst search,setSearch useState redux useEffect constfetchData async constresult awaitaxios http hn.algolia.com api v1 search query search , setData result.data fetchData , search 页面操作改变search，依赖于search的effect重新执行。当返回一个方法时，会在组件清除阶段执行。useEffect是可选清除方式，不返回方法，默认不需要清除 typescriptuseEffect functionhandleStatusChange status setIsOnline status.isOnline ChatAPI.subscribeToFriendStatus props.friend.id,handleStatusChange Specifyhowtocleanupafterthiseffect returnfunctioncleanup ChatAPI.unsubscribeFromFriendStatus props.friend.id,handleStatusChange 错误处理 typescriptconst isError,setIsError useState false useEffect constfetchData async setIsError false setIsLoading true try constresult awaitaxios url setData result.data catch error setIsError true setIsLoading false fetchData , url 使用一个state存放错误，并显示在页面 自定义Hook我们将获取数据，错误判断，加载等从APP组件抽离，形成一个自定义的Hooks。 typescriptconstuseHackerNewsApi const data,setData useState hits const url,setUrl useState https hn.algolia.com api v1 search query redux , const isLoading,setIsLoading useState false const isError,setIsError useState false useEffect constfetchData async setIsError false setIsLoading true try constresult awaitaxios url setData result.data catch error setIsError true setIsLoading false fetchData , url return data,isLoading,isError ,setUrl 在App中使用 jsxfunctionApp const query,setQuery useState redux const data,isLoading,isError ,doFetch useHackerNewsApi return Fragment formonSubmit event doFetch http hn.algolia.com api v1 search query query event.preventDefault inputtype text value query onChange event setQuery event.target.value buttontype submit Search button form ... Fragment 同样可以抽离初始值 jsximportReact, Fragment,useState,useEffect from react importaxiosfrom axios constuseDataApi initialUrl,initialData const data,setData useState initialData const url,setUrl useState initialUrl const isLoading,setIsLoading useState false const isError,setIsError useState false useEffect constfetchData async setIsError false setIsLoading true try constresult awaitaxios url setData result.data catch error setIsError true setIsLoading false fetchData , url return data,isLoading,isError ,setUrl functionApp const query,setQuery useState redux const data,isLoading,isError ,doFetch useDataApi https hn.algolia.com api v1 search query redux , hits , return Fragment formonSubmit event doFetch http hn.algolia.com api v1 search query query , event.preventDefault inputtype text value query onChange event setQuery event.target.value buttontype submit Search button form isError div Somethingwentwrong... div isLoading div Loading... div ul data.hits.map item likey item.objectID ahref item.url item.title a li ul Fragment exportdefaultApp 代码分片 code spliting 大部分应用会被打包到一个文件中，但是有很多代码不一定是首屏需要用到的。当项目越来越大时，我们可以分开打包，在运行时再加载。Code Spliting可以帮助我们实现lazy load，减少在初次加载时下载的代码数量。 import 引入Code Spliting的最佳方式在使用import的动态引入语法。之前 typescriptimport add from . math console.log add 16,26 之后 typescriptimport . math .then math console.log math.add 16,26 如果是使用create react app创建的react应用，当webpack处理时，会自动开始Code Spliting，如果是自己从头创建的，则需要配置webpack。 React.lazyReact.lazy允许我们渲染一个动态的import像一个普通的组件一样。之前 typescriptimportOtherComponentfrom . OtherComponent 之后 typescriptconstOtherComponent React.lazy import . OtherComponent 当OtherComponet被渲染时，才会自动加载包含这个组件的编译文件。React.lazy必须使用一个调用了import 的函数做为参数，返回一个promise，promiseresolve时是模块。动态加载模块需要在 Suspense 组件内使用。 typescriptimportReact, Suspense from react constOtherComponent React.lazy import . OtherComponent functionMyComponent return div Suspensefallback div Loading... div OtherComponent Suspense div Fallback属性接受一个reactcomponent当子组件在加载时展示，也可以放多个动态加载组件在内。 typescriptimportReact, Suspense from react constOtherComponent React.lazy import . OtherComponent constAnotherComponent React.lazy import . AnotherComponent functionMyComponent return div Suspensefallback div Loading... div section OtherComponent AnotherComponent section Suspense div 错误处理如果其他模块加载失败，例如因为网络原因，会触发一个错误，你可以通过展示一个良好用户体验的页面来处理这种错误既， ErrorBoundaries 。一旦创建了ErrorBoundaries在任何地方展示，当发生错误时展示一个错误状态。 typescriptimportReact, Suspense from react importMyErrorBoundaryfrom . MyErrorBoundary constOtherComponent React.lazy import . OtherComponent constAnotherComponent React.lazy import . AnotherComponent constMyComponent div MyErrorBoundary Suspensefallback div Loading... div section OtherComponent AnotherComponent section Suspense MyErrorBoundary div 基于路由的Code Spliting如何妥善使用CodeSpliting但是不影响用户的使用体验，一个合适的实践是基于路由来处理，一下是使用 React Router 组件的示例。 typescriptimportReact, Suspense,lazy from react import BrowserRouterasRouter,Route,Switch from react router dom constHome lazy import . routes Home constAbout lazy import . routes About constApp Router Suspensefallback div Loading... div Switch Routeexactpath component Home Routepath about component About Switch Suspense Router 名称导出当前React.lazy仅支持defaultexport，如果希望使用nameexport可以如下操作 ManyComponents.jsexportconstMyComponent ... exportconstMyUnusedComponent ... MyComponent.jsexport MyComponentasdefault from . ManyComponents.js MyApp.jsimportReact, lazy from react constMyComponent lazy import . MyComponent.js Context Context提供了数据沿组件树一路传递的方法，而不需要手动赋值给props一级级传递数据在典型的react应用里，数据通过props上下传递，但是对于一些特定的数据，例如全球化参数，主题等，很多组件都需要这些数据，Context提供了在组件中共享数据的方式，而不是在每一级组件中被显式的赋值。 何时使用ContextContext被设计为共享那些被考虑为 global 的数据，例如主题，当前用户等。 tsx Contextletsuspassavaluedeepintothecomponenttree withoutexplicitlythreadingitthrougheverycomponent. Createacontextforthecurrenttheme with light asthedefault .constThemeContext React.createContext light classAppextendsReact.Component render UseaProvidertopassthecurrentthemetothetreebelow. Anycomponentcanreadit,nomatterhowdeepitis. Inthisexample,we repassing dark asthecurrentvalue.return ThemeContext.Providervalue dark Toolbar ThemeContext.Provider Acomponentinthemiddledoesn thaveto passthethemedownexplicitlyanymore.functionToolbar return div ThemedButton div classThemedButtonextendsReact.Component AssignacontextTypetoreadthecurrentthemecontext. ReactwillfindtheclosestthemeProvideraboveanduseitsvalue. Inthisexample,thecurrentthemeis dark .staticcontextType ThemeContext render return Buttontheme this.context 在使用Context之前Context主要用于在很多不同层级组件共享数据，需要小心使用，因为它使组件重用变的困难。 如果仅仅是想避免在多级组件中传递数据，componentcomposition提供了一个更简单的解决方案 API React.createContext typescriptconstMyContext React.createContext defaultValue 创建一个 Context 对象，当订阅了这个Context对象的组件被渲染时，会从组件树中最靠近的Provider读到实时的Context值。 Context.Provider typescript MyContext.Providervalue somevalue 每个Context对象需要和Provider组件配合使用，帮助子组件订阅Context对象的变化。属性 value 的值会被所有订阅了这个context的子组件使用。一个Provider可以被连接到多个子组件。当Provider的属性value发生变化时，所有被Provider包括的消费组件会被重新render。这种重新render不被 shouldComponentUpdate 限制。新旧值的变化和 Object.is 使用了相同的算法。 Class.contextType typescriptclassMyClassextendsReact.Component componentDidMount letvalue this.context performaside effectatmountusingthevalueofMyContext componentDidUpdate letvalue this.context ... componentWillUnmount letvalue this.context ... render letvalue this.context rendersomethingbasedonthevalueofMyContext MyClass.contextType MyContext contextType属性可以被使用Context对象赋值，你可以使用this.context来消费上下文数据，this.context可以在任意声明周期，甚至是render中使用。 这个api只可以订阅单个Context对象，如果需要从多个中获取，参考 ConsumingMultipleContexts 如果你有使用实验中的类属性语句，你可以使用静态类属性来初始化Context。 typescriptclassMyClassextendsReact.Component staticcontextType MyContext render letvalue this.context rendersomethingbasedonthevalue Context.Consumer tsx MyContext.Consumer value rendersomethingbasedonthecontextvalue MyContext.Consumer 这是一个订阅Context变化的react组件，可以帮助我们在函数式组件中使用上下文。子组件必须是一个function，这个function接受一个Context的当前值为参数而且返回一个React元素，这个值会和组件树中最近的Provider值相同。 Context.displayNameContext对象接受一个 displayName 字符串属性，ReactDevTools使用这个字符串来显示Context。例如 tsxconstMyContext React.createContext somevalue MyContext.displayName MyDisplayName MyContext.Provider MyDisplayName.Provider inDevTools MyContext.Consumer MyDisplayName.Consumer inDevTools 示例 动态Context一个更复杂的动态Context的例子如下，主要思路是将Provider的属性value放入组件的state。 theme context.js exportconstthemes light foreground 000000 ,background eeeeee , ,dark foreground ffffff ,background 222222 , , exportconstThemeContext React.createContext themes.dark defaultvalue themed button.js import ThemeContext from . theme context classThemedButtonextendsReact.Component render letprops this.props lettheme this.context return button ...props style backgroundColor theme.background ThemedButton.contextType ThemeContext exportdefaultThemedButton app.js import ThemeContext,themes from . theme context importThemeTogglerButtonfrom . theme toggler button classAppextendsReact.Component constructor props super props this.toggleTheme this.setState state theme state.theme themes.dark themes.light themes.dark, Statealsocontainstheupdaterfunctionsoitwill bepasseddownintothecontextproviderthis.state theme themes.light,toggleTheme this.toggleTheme, render Theentirestateispassedtotheproviderreturn ThemeContext.Providervalue this.state Content ThemeContext.Provider functionContent return div ThemeTogglerButton div ReactDOM.render App ,document.root 订阅多个Context为了保持Context渲染速度，React需要保持每个Context在树中是分开的节点。 Themecontext,defaulttolightthemeconstThemeContext React.createContext light Signed inusercontextconstUserContext React.createContext name Guest , classAppextendsReact.Component render const signedInUser,theme this.props Appcomponentthatprovidesinitialcontextvaluesreturn ThemeContext.Providervalue theme UserContext.Providervalue signedInUser Layout UserContext.Provider ThemeContext.Provider functionLayout return div Sidebar Content div AcomponentmayconsumemultiplecontextsfunctionContent return ThemeContext.Consumer theme UserContext.Consumer user ProfilePageuser user theme theme UserContext.Consumer ThemeContext.Consumer ErrorBoundaries 在过去，组件内的js错误通常会破坏组件内部的状态，并且在下一次render时报错，而且react没有提供一种方式从错误中恢复。 介绍部分UI代码的错误不应该破坏掉整个APP。为了解决这个问题，React16引入了一个新的概念 errorboundary 。ErrorBoundaries是一个react组件，用于处理子组件树中所有的js错误，记录这些错误，并且显示一个fallback页面，而不是让整个组件树崩溃，ErrorBoundaries处理所有在render，LifeCycle，constructors中注意 ErrorBoundaries无法捕捉这些错误1.事件处理。2.异步代码。3.服务端渲染。4.ErrorBoundaries自身的异常。当一个类组件，定义了方法 staticgetDerivedStateFromError 或者 componentDidCatch 时会被认为是一个ErrorBoundary组件。使用 staticgetDerivedStateFromError 来render一个发生异常时的UI，使用 componentDidCatch 来记录错误信息。 typescriptclassErrorBoundaryextendsReact.Component constructor props super props this.state hasError false staticgetDerivedStateFromError error UpdatestatesothenextrenderwillshowthefallbackUI.return hasError true componentDidCatch error,errorInfo YoucanalsologtheerrortoanerrorreportingservicelogErrorToMyService error,errorInfo render if this.state.hasError YoucanrenderanycustomfallbackUIreturn h1 Somethingwentwrong. h1 returnthis.props.children 然后你可以在普通组件使用 tsx ErrorBoundary MyWidget ErrorBoundary ErrorBoundaries和trycatch相同的工作方式，但是仅类组件可以作为ErrorBoundaries。实践中，大部分情况下，会定义一个ErrorBoundaries然后在整个应用中使用。 何处使用可以在整个应用外层使用，提示somethingiserror类似服务端处理的方式。也可以在限定范围使用，防止异常让整个应用崩溃。 捕捉错误的新方式在引入ErrorBoundaries之前，React团队进行过讨论，因为在某些场景，白屏可能比显示错误的信息更合适，例如支付应用，聊天应用等。因此需要根据不同的场景考虑如何使用。 ForwardingRefs RefFowarding是一个用户把ref转发绑定到子元素上的技术手段，对大部分应用组件来说不会用到，但是对于一些类库组件确可能很有用。 ForwardingrefstoDOMcomponents考虑一个 FancyButton 组件，渲染一个元素的dom元素如下 tsxfunctionFancyButton props return buttonclassName FancyButton props.children button React组件隐藏了自己的实现细节，其他使用FancyButton的组件一般不需要内部button组件的ref。这是好的设计，因为能过阻止其他组件过度依赖内部的DOM结构。但是一些应用层级的组件可能倾向于向使用传统的DOM一样使用这些组件，用于管理焦点，选中，动画等。refforward是一个可选的特性，让组件可以获取到自己的ref并传递给下级子组件。例如 tsxconstFancyButton React.forwardRef props,ref buttonref ref className FancyButton props.children button YoucannowgetarefdirectlytotheDOMbutton constref React.createRef FancyButtonref ref Clickme FancyButton 通过这种方式，使用FancyButton的组件，可以直接获取到内部Button的ref。1.我们使用React.createRef创建了一个Reactref，并将它赋值给ref变量。2.通过制定JSX的属性，我们将ref传递给FancyButton组件。3.React传递ref通过调用方法 props,ref ...。4.我们将ref下放绑定到button。5.当ref被指定后，ref.current会被指到buttonDOM节点。第二个参数ref仅在使用React.forwardRef中可以使用，普通的函数组件或者类组件无法获取到ref参数。refforward不限于原生DOM元素，react元素同样可以。 Fragments React中可能会遇到一个组件系统返回多个元素的场景，使用Framents帮助我们返回多个元素而不需要给DOM添加额外的节点。 tsxrender return React.Fragment ChildA ChildB ChildC React.Fragment 动机一个常见的场景是返回多个元素，例如 tsxclassTableextendsReact.Component render return table tr Columns tr table Colums 需要返回多个td来渲染页面，代码可能这样写 tsxclassColumnsextendsReact.Component render return div td Hello td td World td div 但是这会像DOM中添加div导致失效。 用法 tsxclassColumnsextendsReact.Component render return React.Fragment td Hello td td World td React.Fragment 于是我们这样使用。 简写 tsxclassColumnsextendsReact.Component render return td Hello td td World td 使用 可以有相同的效果，唯一的区别是不支持key属性。 带key属性的Framentskey是Frament唯一支持的属性。 Higher OrderComponents 高阶组件是复用组件逻辑的推荐技术，HOCs并不是ReactAPI的一部分，他是React生态中出现的模式。具体来说， 高阶组件是一个方法，接受一个组件作为参数，返回另外一个组件 。 tsxconstEnhancedComponent higherOrderComponent WrappedComponent 一般组件将props转换成UI，但高阶组件是将一个组件转换成另一个组件。高阶组件在React的第三方库中普遍存在，比如Redux s的connect。 使用HOC解决横切关注点问题Cross CuttingConcerns 横切关注点，部分关注点横切程序中的多个模块，既在多个模块中都有他，他们既被称为横切关注点，一个典型的例子就是日志系统。我们之前使用minix处理这个问题，但是后来意识到带来的问题比解决的问题更多。在react中组件是主要的重用单位，但是你会发现一些奇怪的情况，传统组件无法处理。例如下面的CommentList组件，订阅一个外部数据源，然后渲染一个评论列表。 tsxclassCommentListextendsReact.Component constructor props super props this.handleChange this.handleChange.bind this this.state DataSource issomeglobaldatasourcecomments DataSource.getComments componentDidMount SubscribetochangesDataSource.addChangeListener this.handleChange componentWillUnmount CleanuplistenerDataSource.removeChangeListener this.handleChange handleChange Updatecomponentstatewheneverthedatasourcechangesthis.setState comments DataSource.getComments render return div this.state.comments.map comment Commentcomment comment key comment.id div 集成其他库React能在任何web应用中使用，这个主题集中于React和其他类似于jQuery的集成，相同的idea也可以用于React组件和其他已存在代码的集成上。 与基于操作DOM的其他插件集成React对不由React创建的DOM元素的变化没有察觉，React的更新依赖于它自身的内部抽象，如果相同的DOM被其他的库改变，React会陷入困惑而且不会恢复。这不意味着无法或者很难将React和以其他方式影响DOM的方式相结合，只是你需要留意做的事情。最简单的避免冲突的方式是在更新状态时阻止React组件。你可以渲染一个React没有理由去更新的元素，例如空div div 如何解决问题 jsxclassSomePluginextendsReact.Component componentDidMount this. el this.el this. el.somePlugin componentWillUnmount this. el.somePlugin destroy render return divref el this.el el 和Backbone的集成内容跳过。 深入了解JSX本质上讲，JSX只是提供了一种语法糖，实际上是 React.createElement component,props,...children 方法。JSX代码 jsx MyButtoncolor blue shadowSize 2 ClickMe MyButton 编译成 javascriptReact.createElement MyButton, color blue ,shadowSize 2 , ClickMe 也可以使用自包含，没有子元素的标签 jsx divclassName sidebar 编译成 javascriptReact.createElement div , className sidebar 指定ReactElement类型JSX标签首字母大写时，即表示这是一个Reactelement类型。首字母大写类型的JSX标签指向一个React组件，这些标签会直接编译成名称变量，所以如果你使用JSX Foo 表达式， Foo 必须在作用域中。 React必须在作用域中因为JSX编译调用React.createElement，React库必须在JSX代码的作用域中，例如，下面代码中的两个import都是有必要的，尽管React和CustomButton没有在JavaScript代码中直接使用到。 jsximportReactfrom react importCustomButtonfrom . CustomButton functionWarningButton returnReact.createElement CustomButton, color red ,null return CustomButtoncolor red 如果没有使用JavaScript编译工具来加载React，而是直接使用的 script 标签，那React已经在全局作用域中。 使用.符号同样可以使用dot notaion符号来引用React组件，这样可以方便与使用单个模块来导出多个React组件，例如如果 MyComponents.DatePicker 是一个组件，你可以在JSX中直接这样使用 jsximportReactfrom react constMyComponents DatePicker functionDatePicker props return div Imaginea props.color datepickerhere. div functionBlueDatePicker return MyComponents.DatePickercolor blue 用户定义组件必须大写首字母当一个元素类型使用小写字母开头时，它指向的时内置组件，例如 div 或者 span ，内置组件在传递给createElement时是字符串的形式，例如 div 或者 span ，但是首字母大写的组件传递给createElement时是React.createElement Foo 的形式，所以对应的组件必须要有定义，或者从其他文件中引入。推荐使用大写开头来命名组件，如果已经有了小写开头的组件，建议赋值给大写开头的变量后再使用。 在运行时指定类型不能使用表达式作为React元素的类型，如果你想使用表达式作为元素类型，只需要将表达式的值赋给一个大写字母开头的变量。例如 jsximportReactfrom react import PhotoStory,VideoStory from . stories constcomponents photo PhotoStory,video VideoStory functionStory props Wrong JSXtypecan tbeanexpression.return components props.storyType story props.story 如下修复 jsximportReactfrom react import PhotoStory,VideoStory from . stories constcomponents photo PhotoStory,video VideoStory functionStory props Correct JSXtypecanbeacapitalizedvariable.constSpecificStory components props.storyType return SpecificStorystory props.story JSX中的属性有几个不同的方式在JSX中指定属性 使用JavaScript表达式作为属性可以使用JavaScript表达式作为属性，使用 包围，例如 jsx MyComponentfoo 1 2 3 4 if 语句和 for 循环在JavaScript中并不是表达式，因此不能再JSX中直接使用，取而代之的，你可以这样使用 jsxfunctionNumberDescriber props letdescription if props.number 2 0 description strong even strong else description i odd i return div props.number isan description number div 字符串可以直接在属性中使用字符串，以下两种表达是相同的 jsx MyComponentmessage helloworld MyComponentmessage helloworld 当直接使用字符串是，他的值是HTML unescaped，下面两种表示相同 jsx MyComponentmessage lt 3 MyComponentmessage 3 属性的默认值是”True“如果你没有给属性赋予任何值，那它的值将会是 true ，以下两中表达相同 jsx MyTextBoxautocomplete MyTextBoxautocomplete true 扩展属性如果你已经有了一个属性对象，你想在JSX中使用，可以使用 ... 作为扩展操作来传递整个属性对象，下面两个表达相同 jsxfunctionApp1 return GreetingfirstName Ben lastName Hector functionApp2 constprops firstName Ben ,lastName Hector return Greeting ...props JSX子元素在JSX表达方式中，被标签包围的内容，会被构造成一个特色的属性 props.children 。有以下几种不同的方式在处理子元素 字符串可以在标签中放置一个字符串， props.children 也会被指定成这个字符串，这在很多内置的HTML元素中会用到。 jsx MyComponent Helloworld MyComponent 这是一种可用的表达形式， MyComponent 组件的 props.children 会简单的变成字符串 Helloworld 字符串中的换行会被移除。 JSX子元素你可以提供更多的JSX元素作为子组件，在展示一些嵌套时很有用 jsx MyContainer MyFirstComponent MySecondComponent MyContainer 你也能混合几种不同类型的子元素，例如JSX元素和字符串元素，他们像HTML一样组合在一起。 JSX div Hereisalist ul li Item1 li li Item2 li ul div React组件也可以返回一个元素数组。 jsxrender Noneedtowraplistitemsinanextraelement return Don tforgetthekeys likey A Firstitem li , likey B Seconditem li , likey C Thirditem li , JavaScript表达式作为子元素你可以使用JavaScript表达式作为子元素，只需要用 来包含，例如以下两种表达相同 jsx MyComponent foo MyComponent MyComponent foo MyComponent 在用于渲染未知长度的列表时经常用到。 jsxfunctionItem props return li props.message li functionTodoList consttodos finishdoc , submitpr , nagdantoreview return ul todos.map message Itemkey message message message ul JavaScript表达式也能和其他类型混合，例如 jsxfunctionHello props return div Hello props.addressee div 方法作为子组件通常来说，JSX表达式会被计算为字符串，React元素，一些元素的列表等，但是 props.children 和其他属性一样工作，可以被传递任何数据，例如 jsxfunctionRepeat props letitems for leti 0 i props.numTimes i items.push props.children i return div items div functionListOfTenThings return RepeatnumTimes 10 index divkey index Thisisitem index inthelist div Repeat Booleans，Null和Undefined会被忽视 false ， null ， undefined 和 true 是不可用的子元素，他们不会被渲染，这些Jsx表达式会有相同的结果 jsx div div div div false div div null div div undefined div div true div 这在有条件的渲染React组件时经常用到，例如下面的 Header 只有在 showHeader 时 true 时渲染 jsx div showHeader Header Content div 注意，这对一些可转化成false的表达式不适用，例如数字0。如果你想渲染这些类型的数据，可以将他们转化成string，例如 jsx div MyJavaScriptvariableis String myVariable . div 性能优化React使用了很聪明的技术来优化更新DOM的次数，对大部分应用来说，使用React不用做任何事情，也能有优秀的性能。尽管如此，哦我们一人有提升React应用的方法。 使用生产配置来编译如果你在衡量或者试图优化Reactapp的性能，首先要确保你在使用最优的生产编译配置。在默认设置下，React包含了很多有用的警告，这些警告在开发中非常有用，但是他们让React变大更加庞大和缓慢，所以在部署应用时，一定要确保使用的是生产版本。如果你不确定编译设定是否争取，你可以通过安装React开发工具插件来检查。 CreateReactApp如果你的应用是使用CreateReactApp脚手架建设的，执行 shellnpmrunbuild 这会帮你编译应用的生产版本，这是你在发布前唯一需要执行的操作。 Signle FileBuilds我们提供编译版本的React和ReactDom作为单个文件 js scriptsrc https unpkg.com react 16 umd react.production.min.js script scriptsrc https unpkg.com react dom 16 umd react dom.production.min.js script webpackWebpackv4 会自动最小化你的代码，当设置成 production 模式时。 jsconstTerserPlugin require terser webpack plugin module.exports mode production ,optimization minimizer newTerserPlugin additionaloptionshere , , 记住仅在 production 编译模式下需要这样设定，在开发环境下请不要使用 TerserPlugin ，因为这会隐藏React的提醒，而且让编译变得缓慢。 使用ChromePerformaceTab可视化组件装载过程在开发模式下，使用Chrome的性能工具，可以讲组件如何加载，更新，卸载的过程可视化出来 ReactcomponentsinChrometimeline 使用React开发工具来可视化性能 虚拟化长列表如果你的应用需要渲染一个长列表 几百或上千行 ，我们建议使用”windowing“的技术，这个技术仅会渲染一小部分子集，这能减少DOM节点创建时间。 react window 和 react virtualized 时两个流行的窗口化库，他们提供了集中重用组件来展示列表等数据，你也可以创建你自己的窗口化组件，例如 Twitter 的做法，如果你想给你的组件量身定制的话。 避免调和React构建和维持了一个针对已渲染UI的内部表现，包含了所有你从组件中return的元素，这个表现可以让React仅在必要时才创建和操作DOM元素。当一个组件的属性或者状态改变时，React会计算新的renturn和之前的镜像比较，当不一样时，React会更新Dom。尽管React只更新改变的DOM节点，重渲染依然会花费一些时间，在大部分情况下这不会成为一个问题，但是当这种缓慢可以被察觉到时，你可以通过重载生命周期函数 shouldComponentUpdate 来是实现速度优化。在大多数情况下，你可以通过继承 React.PureComponent 来替代重写 shouldComponentUpdate ，这个继承实际上实现了一个 shouldComponentUpdate 方法，这个方法回浅比较当前和上一个状态的props和state。 ShouldComponentUpdate的执行过程 shouldcomponentupdate 其他当你处理深层嵌套的对象数据时，更新他们可能会事件繁琐的事情，这时可检查 Immer 或 immutability helper 库，这可以在不牺牲性能的同时快速更新到对象。 Portals提供一种方法讲允许子节点渲染到父组件意外的DOM节点。 jsxReactDOM.createPortal child,container 第一个参数是任意可被渲染你的React元素，第二个参数，是一个DOM元素 用法一般来讲，当从组件周昂返回一个元素时，它被挂在与DOM上作为一个子元素，但是有些时候，讲子元素插入到DOM的任意位置也是有用的，一个典型的使用场景便是 Modal ， tooltips 等。 事件冒泡尽管Portal可以在DOM树的任意地方，但是它依然和普通的Reactchild的行为一致，作为一个portal，它仍然在reacttree的原来位置，而无论DOM树是怎样的。这包括事件冒泡，一个事件从portal内部发出，会沿着react树向祖先元素传播。 ProfilerAPI Profiler 可以衡量一个React应用的渲染事件，帮助定位应用中的缓慢部分。注意 Profiling添加了一些额外的部分，所以它在生产模式编译时会被禁用。对与生产下进行探查的需求，React提供了一个特殊的探查版用于打开探查功能， fb.me react profiling 用法一个 Profiler 可以被加在React树的任意地方，来很亮这部分树的渲染耗时。他需要两个属性 id 和 onRender 回调。例如下面探查一个 Navigation 组件的方式 jsxrender App Profilerid Navigation onRender callback Navigation ...props Profiler Main ...props App 探查组件可以嵌套或者并排 jsxrender App Profilerid Navigation onRender callback Navigation ...props Profiler Profilerid Main onRender callback Main ...props Profiler App jsxrender App Profilerid Panel onRender callback Panel ...props Profilerid Content onRender callback Content ...props Profiler Profilerid PreviewPane onRender callback PreviewPane ...props Profiler Panel Profiler App 注意， Profiler 尽管是一个轻量的组件，它仍然应该尽在必要时使用，因为它会添加CPU的开销和内存的负担。 onRenderCallback Profiler 需要一个 onRender 方法，React调用这个方法，每当组件出发更新时，他会收到描述渲染时间的参数 jsxfunctiononRenderCallback id, the id propoftheProfilertreethathasjustcommittedphase, either mount ifthetreejustmounted or update ifitre rendered actualDuration, timespentrenderingthecommittedupdatebaseDuration, estimatedtimetorendertheentiresubtreewithoutmemoizationstartTime, whenReactbeganrenderingthisupdatecommitTime, whenReactcommittedthisupdateinteractions theSetofinteractionsbelongingtothisupdate Aggregateorlogrendertimings... React的调和过程React提供了陈述式的API，让我们不用担心每次更新实际上的变化，这让我们编写一个应用程序变得更容易，但是React如何实现的细节可能不是那么显而易见，这篇文章解释了我们在打造Reactdiffing算法中的选择和决定。 动机当你使用React时，唯一你需要思考的关注点时render方法，在下一个状态或者属性更新时，render方法会返回一个不同的React树，于是React需要解决，如何比较两个树，来最有效率的更新UI。有一些通用的算法来处理将一个树转换成另一个树的问题，但是通常拥有O n3 的复杂度，如果我们使用这个算法，那展示1000个元素，将需要对比百万次，代价过于高昂，取而代之的是，React实现了一个启发式的算法基于以下两个假设 1.两个不同类型的元素会产生不同的树。2.开发者可以通过key属性，表示不同渲染的两个元素是否相同。在实践中，这两个假设被验证是可行的。 Diffing算法当diffing两个树时，React首先比价两个root的元素。 元素类型不相同无论什么时候，当root元素有两个不同的类型时，React会直接干掉旧的树，而且构建一个新树来代替。当销毁一个旧的树时，组件实例会收到 componentWillUnmount 方法，当构造一个新树时，新的DOM节点会被插入到DOM中，组件会收到 componentWillMount 然后收到 componentDidMount ，任何和旧树相关的状态会消失掉。 DOM类型而且类型相同当比较两个ReactDOM元素时，React会关注两边的属性，保留相同的，而仅更新有变化的。 组件类型而且类型相同当一个组件更新时，实例依然时同一个，所以状态会在整个渲染过程中保留，React会更新组件实例的属性，来匹配新的袁术，然后调用实例中的 componentWillReceiveProps 方法和 componentWillUpdate 方法。接下来，render方法会被调用，diff算法递归向下调用。 子元素列表默认的，当递归一个DOM节点的子元素时，React简单的列出两边的list，然后按顺序比较。 Keys为了解决这个问题，React支持key属性。 权衡 Refs和DOM Refs提供了一种访问DOM节点或者React元素的方式在典型的React数据流中， props 是唯一的父组件和子组件沟通的方式。为了改变子元素，你需要使用新的属性重新渲染它。然而，仍然有少数的情况你需要直接修改子元素。 何时使用refs有以下几个最佳实践 管理focus，文本选择，或者媒体播放 触发重要的动画 和第三方DOM库集成除非无法实现，否则请尽量避免使用Ref 不要过度使用你可能会认为ref可以做到任何可能的事请，如果你是这样想的，不妨审慎思考一下，是否有其他途径来实现，尤其是组件状态的层级问题是否有正确的设计。 创建Ref可以使用 React.createRef 来创建Refs，通常在构造函数方法内将React元素赋值给一个实例的 ref 属性。一下是一个实例 jsxclassMyComponentextendsReact.Component constructor props super props this.myRef React.createRef render return divref this.myRef 访问Refs当在 render 方法中绑定ref后，node就可以通过ref的current属性来访问到 jsxconstnode this.myRef.current ref的值取决于node的类别 但ref属性在html元素中使用时，在构造函数调用的 React.createRef 会接收到DOM元素作为他的current属性。 但ref属性在自定义组件中用到时，ref对象会接收到一个组件实例作为他的current属性 你不可以在函数式组件中使用ref属性，因为他们不具备一个实例。以下示例展示了他们的区别 给DOM元素添加REF以下示例使用了 ref 来保存一个DOM节点的引用 jsxclassCustomTextInputextendsReact.Component constructor props super props this.textInput React.createRef this.focusTextInput this.focusTextInput.bind this focusTextInput this.textInput.current.focus render return div inputtype text ref this.textInput inputtype button value Focusthetextinput onClick this.focusTextInput div React会在组件加载时将DOM元素赋值给current属性，而且在卸载时赋予null值，ref的更新发生在 componentDidMount 或者 componentDidUpdate 生命周期函数之前。 给Class类型组件添加ref如果在 CustomerTextInput 上层有类似的逻辑，我们可以使用ref来获取到自定义的input而且调用它的 focusTextInput 方法。 JSXclassAutoFocusTextInputextendsReact.Component constructor props super props this.textInput React.createRef componentDidMount this.textInput.current.focusTextInput render return CustomerTextInputref this.textInput 注意这仅当 CustomTextInput 使用class来声明时才有用 给函数式组件添加REF默认的，我们可能没有办法在一个函数式组件中使用ref属性，因为他们并没有一个实例 jsxfunctionMyFunctionComponent return input classParentextendsReact.Component constructor props super props this.textInput React.createRef render 不会正常工作return MyFunctionComponentref this.textInput 如果你想允许人们获取你的函数式组件的ref，你可能要使用forwardRef或者你可以将他转换成一个类声明的组件。然而，你能在函数式组件的内部使用ref，无论指向一个DOM元素，还是一个类声明的元素。 jsxfunctionCustomTextInput props consttextInput useRef null functionhandleClick textInput.current.focus return div inputtype text ref textInput inputtype button value Focusthetextinput onClick handleClick div 向父组件暴露DOMRefs在极其稀有的场景下，你会想要通过父组件访问其子元素的DOM，这通常时不推荐的，因为这打破的组件封装，但是这有时会很有用，当需要监控focus或者计算子元素的位置和大小时。你可能会给子组件添加ref，但是这不是个好主意，你只能得到一个组件实例，而不是一个DOM节点，而且，这在函数式组件中并不可用。如果你在使用React16.3以上的版本，我们推荐使用 refforwarding ，Refforwarding让组件选项透传出任意子元素的ref作为他们自己的ref，这里是一个实例， intherefforwardingdocumentation 如果你使用的是React16.2或者更低，你需要更复杂的方案来实现，你可以使用 thisalternativeapproach 来使用一个命名的属性显式传递ref。在可能的情况下，我们建议不要透传DOM节点。 回调式RefReact也支持另外一种方式设置ref叫做 callbackrefs ，这种方式给了我们更细粒度控制refs的方法不同于使用createRef创建传递一个ref的属性，传递一个方法，这个方法接受一个dom节点或者有一个react组件实例作为参数，他们可以被保存起来，在任意地方被访问。下面是使用这种方式的一个实例 jsxclassCustomTextInputextendsReact.Component constructor props super props this.textInput null this.setTextInputRef element this.textInput element this.focusTextInput FocusthetextinputusingtherawDOMAPIif this.textInput this.textInput.focus componentDidMount autofocustheinputonmountthis.focusTextInput render Usethe ref callbacktostoreareferencetothetextinputDOM elementinaninstancefield forexample,this.textInput .return div inputtype text ref this.setTextInputRef inputtype button value Focusthetextinput onClick this.focusTextInput div 在上面的例子中，父元素通过传递 CustomTextInput 属性获取到子元素input的ref。 创建REF的注意事项如果你使用行内函数来定义的ref回调，他会在update期间更新两次，第一次传递null再次才传递DOM元素，这是因为每次render都会创建一个新的函数实例，react需要清除旧的ref设置一个新的。你可以通过定义ref回调在一个类上。 渲染属性 主题 renderprop 指的是在React组件间共享数据的方法，通过设置方法作为属性的值拥有 render 属性的组件，会使用 render 属性的方法代理自身的render方法，来进行渲染。 jsx DataProviderrender data h1 Hello data.target h1 ReactRouter , Downshift 和 Formik 库都有使用到render属性。在本文中，我们将进行讨论，为什么render属性是有用的，以及如何编写你自己的。 使用Render属性处理关注点横切问题组件在react中是主要的代码复用单元，但是如何将一个组件的状态和行为共享给其他组件并不总是清晰明确的。例如，下面的组件追踪了webapp的鼠标位置 jsxclassMouseTrackerextendsReact.Component constructor props super props this.handleMouseMove this.handleMouseMove.bind this this.state x 0,y 0 handleMouseMove event this.setState x event.clientX,y event.clientY render return divstyle height 100vh onMouseMove this.handleMouseMove h1 Movethemousearound h1 p Thecurrentmousepositionis this.state.x , this.state.y p div 随着鼠标在屏幕上的移动，组件显示他的横纵坐标在p元素节点中。现在问题是，我们如何在其他组件中重用这种行为，换句话说，如果另外的组件需要知道鼠标位置，我们可以封装这种行为，以便我们轻松的在组件中共享和使用吗。使用renderprops的方案 jsxclassCatextendsReact.Component render constmouse this.props.mouse return imgsrc cat.jpg style position absolute ,left mouse.x,top mouse.y classMouseextendsReact.Component constructor props super props this.handleMouseMove this.handleMouseMove.bind this this.state x 0,y 0 handleMouseMove event this.setState x event.clientX,y event.clientY render return divstyle height 100vh onMouseMove this.handleMouseMove Insteadofprovidingastaticrepresentationofwhat Mouse renders,usethe render proptodynamicallydeterminewhattorender. this.props.render this.state div classMouseTrackerextendsReact.Component render return div h1 Movethemousearound h1 Mouserender mouse Catmouse mouse div 使用其他组件和render的区别很重要的一点是，这种模式叫做 renderprops 并不意味着只能用一个命名为 render 的属性来实现这种模式，实际上，任意属性都可以实现这种技术。我们可以轻松的使用 children 属性来实现它。 注意事项 对于继承React.PureComponent的组件谨慎使用使用render属性会抹除使用React.PureComponent组件的优势，如果你在render属性内创建函数，那每次对props的比较都将不相同。 静态类型检查 严格模式 严格模式是高亮潜在问题的一种方式，像Fragment，StrictMode不会渲染任何可见的UI，它激活了潜在的检查和警告严格模式检查仅在开发模式下游泳，他们对生产编译不会有任何影响你可以在应用的任何部分打开strictmode例如 tsximportReactfrom react functionExampleApplication return div Header React.StrictMode div ComponentOne ComponentTwo div React.StrictMode Footer div 在上面的例子中，严格模式检查不会在 Header 和 Footer 组件中生效，只有 ComponentOne 和 ComponentTwo 以及他们的子元素会应用检查。严格模式会在一下几点有助于我们 定位使用不安全什么周期函数的组件 对遗留stringref的使用进行警告 警告弃用的findDOMNode方法 检测意外的副作用 探测将被废弃的contextapi 定位不安全的生命周期某些生命周期方法在异步react应用中可能是不安全的，然而，如果你的应用使用了第三方库，很难确保这些库是否有使用这些到这些生命周期函数，幸运的是，严格模式会帮助到我们。当严格模式开启时，React会列出所有使用了不安全生命周期的组件，而且在console中打印出来 image 20201118174745768 对遗留stringref的使用进行警告我们知道，react提供了两种使用和关联ref的方法，legacystringrefapi和callbackapi，尽管stringref看上去似乎更方便，但是基于 severaldownsides 我们官方推荐使用callbackref代替stringrefReact16.3添加了第三个选项来使用stringref而没有任何缺陷 jsxclassMyComponentextendsReact.Component constructor props super props this.inputRef React.createRef render return inputtype text ref this.inputRef componentDidMount this.inputRef.current.focus 警告弃用的findDOMNode方法React过去支持findDOMNOde方法来打破抽象，直接找到DOM元素。但是现在有了ref所有实际上我们不再需要该方法。 检测意外的副作用概念上讲，React在完成工作可以分为两个阶段 render阶段 确定需要应用到DOM的修改，在这个阶段，React调用 render 然后和上一次的render结果进行比较 commit阶段 React应用变更到DOM，同时也会调用生命周期方法，像 componentDidMount 和 componentDidUpdate 。 探测将被废弃的contextapi 非受控组件 在大多数情况下，我们建议使用受控组件来实现表单，在受控组件中，表单数据被react组件处理。另外一个选项是非受控组件，表单数据将由DOM自身处理非受控 jsxclassFormextendsComponent handleSubmitClick constname this._name.value dosomethingwith name render return div inputtype text ref input this._name input buttononClick this.handleSubmitClick Signup button div 受控 jsxclassFormextendsComponent constructor super this.state name , handleNameChange event this.setState name event.target.value render return div inputtype text value this.state.name onChange this.handleNameChange div 区别在于是否要将form的value保存到状态中。尽管一个非受控组件会保存DOM的真实数据，在某些时候，这对于集成react和非react代码很有用处，而且这种方式看上去代码更少和更高效，但是，我们仍然建议使用受控组件。 默认值在react渲染生命周期中，元素的 value 属性会覆盖DOM的vaule，但使用一个非受控组件时，你通常希望react特别指定默认值，但是在后续的更新中离开。为了处理这种案例，你可以通过传递 defaultValue 代替传递 value 。组件转载后改变defaultValue将不会更新dom的value。 文件类型的input在html中， inputtype file 让用户可以从他们的设备中选择一个或多个文件。在React中， inputtype file 总是一个非受控组件，因为他的值无法被用户设置，而且不可编程。你可以使用FILEAPI来和文件交互，下面的例子展示了如果通过创建一个DOM节点的ref来在提交前访问文件 jsxclassFileInputextendsReact.Component constructor props super props this.handleSubmit this.handleSubmit.bind this this.fileInput React.createRef handleSubmit event event.preventDefault alert Selectedfile this.fileInput.current.files 0 .name render return formonSubmit this.handleSubmit label Uploadfile inputtype file ref this.fileInput label br buttontype submit Submit button form ReactDOM.render FileInput ,document.getElementById root WebComponents react和 WebComponents 为了处理不同的问题而构造，webcomponent为可复用的组件提供了强封装，但是react提供了一个声明式的库来保持DOM和数据的同步，这两个目标是互补的，作为一个开发者，你可以在你的webcomponent中自由的使用react，或者在React中使用webcomponent。大多数使用react的用户不会使用到webcomponent，但是你可能会想使用，尤其是当你使用第三方的由webcomponent编写的UI组件时。 在react中使用webcomponent jsxclassHelloMessageextendsReact.Component render return div Hello x search this.props.name x search div ","categorie":"React-简介"}]
[{"route":"/docs/react/INTRO.html","content":" React使用ReactHooks的无状态组件，在每次渲染时，包括组件内的函数，都会保留所有state，props在执行时刻的值，这一点和class版本的组件具有很大的差异，class版本会取到最新值。 typescriptimportReact, Component from react classOldAppextendsComponent constructor props super props this.state count 1 testOnclick setTimeout console.log this.state.count ,3000 render return div div oldApp div div this.state.count div buttononClick this.setState count this.state.count 1 add button buttononClick this.testOnclick show button div exportdefaultOldApp 多次点击add，交错点击show，console里输出最新状态的countn次。 typescriptfunctionApp const count,setCount useState name 1 functionhandleAlertClick setTimeout alert count.name ,3000 return divclassName App OldApp p count.name p buttononClick setCount name count.name 1 add button buttononClick handleAlertClick alert button div exportdefaultApp 多次点击add，交错点击alert，console多次出现被调用当时的值。class版本可以使用闭包修复，实际Hooks依赖JavaScript闭包。如果希望无状态组件获取到最新值，想class这样的表现，可以使用 useRef typescriptfunctionApp const count,setCount useState num 1 constlastCount useRef count functionhandleAlertClick lastCount.current count setTimeout console.log lastCount.current.num ,3000 return divclassName App p count.num p buttononClick setCount num count.num 1 add button buttononClick handleAlertClick alert button div ReactHooks useMemo 只有在某个依赖项改变时才会重新计算 typescriptconstmemoizedValue useMemo computeExpensiveValue a,b , a,b useCallback 把内联函数以及依赖数组作为参数传入，将返回回调函数的memoized版本。 typescriptconstmemoizedCallback useCallback doSomething a,b , a,b , 直接定义的函数，在每次渲染时其实都会变化，这样的函数无法作为其他Hook的依赖存在，通过useCallback定义的函数，可作为其他hooks的依赖存在。当有多个useEffect，我们希望抽象出useEffect相同部分的逻辑，这部分逻辑依赖于props或者state时，可以考虑使用useCallback。 useContext 上下文 typescriptimportReactfrom react exportdefaultReact.createContext null jsximportReact, useEffect,useState,useRef,useReducer,useContext from react import . App.css importTestfrom . Test importToDoContextfrom . ToDoContext functionApp const count,dispatch useReducer reducer, num 1 functionreducer state,action switch action.type case add return ...state,num state.num 1 return ToDoContext.Providervalue count,dispatch Test Test ToDoContext.Provider exportdefaultApp jsximportReact, useContext from react importToDoContextfrom . ToDoContext functionTest const count,dispatch useContext ToDoContext return div count.num div exportdefaultTest 上下文用于解决React层层传递数据的问题，被包裹的子组件可以获取到全局数据，通常全局状态树会使用到上下文。 useEffect 在render之后执行的的方法，可以理解为 componentDidMount 或者 componentDidUpdate 生命周期经常完成的操作，但是不一样的是，我们可以通过传递依赖的形式，确保代码仅在依赖变化时执行，这点我们之前使用 shouldComponentUpdate 进行 props 的对比类似。 useRef 使用useRef创建的对象和之间创建的对象的不同之处在于，useRef返回的对象，在每次使用时会拿到最新值，而不是当次渲染值。 useReducer 当改变状态的逻辑很复杂时，我们通常使用useReducer来实现，而其他地方只需要dispatch相应的type不需要关心如何改变。同时结合useContext我们可以做到统一的状态树管理 useEffect详解useEffect用来处理会有副作用的操作，比如之前我们在生命周期函数中常常使用的获取数据操作。 typescriptuseEffect async constresult awaitaxios https hn.algolia.com api v1 search query redux , setData result.data 但是这样并不理想，因为不经在组件加载时会执行，在组件更新时也会执行，因此，对于只需要在加载阶段执行的操作，我们通常给予一个空依赖。 typescriptuseEffect async constresult awaitaxios https hn.algolia.com api v1 search query redux , setData result.data , 如此在第一次执行之后，useEffect不会再执行，因为依赖未变化 为空 。但是这样依然不完美，useEffect并不希望函数有返回，而异步函数实际上会返回一个 AsyncFunction ，会报警告，因此我们可以这样优化。 typescriptuseEffect constfetchData async constresult awaitaxios https hn.algolia.com api v1 search query redux , setData result.data fetchData , 以上操作实际使用effects模拟了传统的生命周期函数 ComponentDidMount 。而实际上我们应该用不同的眼光来看待 useEffect 。例如常见的查询获取数据操作 typescriptconst search,setSearch useState redux useEffect constfetchData async constresult awaitaxios http hn.algolia.com api v1 search query search , setData result.data fetchData , search 页面操作改变search，依赖于search的effect重新执行。当返回一个方法时，会在组件清除阶段执行。useEffect是可选清除方式，不返回方法，默认不需要清除 typescriptuseEffect functionhandleStatusChange status setIsOnline status.isOnline ChatAPI.subscribeToFriendStatus props.friend.id,handleStatusChange Specifyhowtocleanupafterthiseffect returnfunctioncleanup ChatAPI.unsubscribeFromFriendStatus props.friend.id,handleStatusChange 错误处理 typescriptconst isError,setIsError useState false useEffect constfetchData async setIsError false setIsLoading true try constresult awaitaxios url setData result.data catch error setIsError true setIsLoading false fetchData , url 使用一个state存放错误，并显示在页面 自定义Hook我们将获取数据，错误判断，加载等从APP组件抽离，形成一个自定义的Hooks。 typescriptconstuseHackerNewsApi const data,setData useState hits const url,setUrl useState https hn.algolia.com api v1 search query redux , const isLoading,setIsLoading useState false const isError,setIsError useState false useEffect constfetchData async setIsError false setIsLoading true try constresult awaitaxios url setData result.data catch error setIsError true setIsLoading false fetchData , url return data,isLoading,isError ,setUrl 在App中使用 jsxfunctionApp const query,setQuery useState redux const data,isLoading,isError ,doFetch useHackerNewsApi return Fragment formonSubmit event doFetch http hn.algolia.com api v1 search query query event.preventDefault inputtype text value query onChange event setQuery event.target.value buttontype submit Search button form ... Fragment 同样可以抽离初始值 jsximportReact, Fragment,useState,useEffect from react importaxiosfrom axios constuseDataApi initialUrl,initialData const data,setData useState initialData const url,setUrl useState initialUrl const isLoading,setIsLoading useState false const isError,setIsError useState false useEffect constfetchData async setIsError false setIsLoading true try constresult awaitaxios url setData result.data catch error setIsError true setIsLoading false fetchData , url return data,isLoading,isError ,setUrl functionApp const query,setQuery useState redux const data,isLoading,isError ,doFetch useDataApi https hn.algolia.com api v1 search query redux , hits , return Fragment formonSubmit event doFetch http hn.algolia.com api v1 search query query , event.preventDefault inputtype text value query onChange event setQuery event.target.value buttontype submit Search button form isError div Somethingwentwrong... div isLoading div Loading... div ul data.hits.map item likey item.objectID ahref item.url item.title a li ul Fragment exportdefaultApp 代码分片 code spliting 大部分应用会被打包到一个文件中，但是有很多代码不一定是首屏需要用到的。当项目越来越大时，我们可以分开打包，在运行时再加载。Code Spliting可以帮助我们实现lazy load，减少在初次加载时下载的代码数量。 import 引入Code Spliting的最佳方式在使用import的动态引入语法。之前 typescriptimport add from . math console.log add 16,26 之后 typescriptimport . math .then math console.log math.add 16,26 如果是使用create react app创建的react应用，当webpack处理时，会自动开始Code Spliting，如果是自己从头创建的，则需要配置webpack。 React.lazyReact.lazy允许我们渲染一个动态的import像一个普通的组件一样。之前 typescriptimportOtherComponentfrom . OtherComponent 之后 typescriptconstOtherComponent React.lazy import . OtherComponent 当OtherComponet被渲染时，才会自动加载包含这个组件的编译文件。React.lazy必须使用一个调用了import 的函数做为参数，返回一个promise，promiseresolve时是模块。动态加载模块需要在 Suspense 组件内使用。 typescriptimportReact, Suspense from react constOtherComponent React.lazy import . OtherComponent functionMyComponent return div Suspensefallback div Loading... div OtherComponent Suspense div Fallback属性接受一个reactcomponent当子组件在加载时展示，也可以放多个动态加载组件在内。 typescriptimportReact, Suspense from react constOtherComponent React.lazy import . OtherComponent constAnotherComponent React.lazy import . AnotherComponent functionMyComponent return div Suspensefallback div Loading... div section OtherComponent AnotherComponent section Suspense div 错误处理如果其他模块加载失败，例如因为网络原因，会触发一个错误，你可以通过展示一个良好用户体验的页面来处理这种错误既， ErrorBoundaries 。一旦创建了ErrorBoundaries在任何地方展示，当发生错误时展示一个错误状态。 typescriptimportReact, Suspense from react importMyErrorBoundaryfrom . MyErrorBoundary constOtherComponent React.lazy import . OtherComponent constAnotherComponent React.lazy import . AnotherComponent constMyComponent div MyErrorBoundary Suspensefallback div Loading... div section OtherComponent AnotherComponent section Suspense MyErrorBoundary div 基于路由的Code Spliting如何妥善使用CodeSpliting但是不影响用户的使用体验，一个合适的实践是基于路由来处理，一下是使用 React Router 组件的示例。 typescriptimportReact, Suspense,lazy from react import BrowserRouterasRouter,Route,Switch from react router dom constHome lazy import . routes Home constAbout lazy import . routes About constApp Router Suspensefallback div Loading... div Switch Routeexactpath component Home Routepath about component About Switch Suspense Router 名称导出当前React.lazy仅支持defaultexport，如果希望使用nameexport可以如下操作 ManyComponents.jsexportconstMyComponent ... exportconstMyUnusedComponent ... MyComponent.jsexport MyComponentasdefault from . ManyComponents.js MyApp.jsimportReact, lazy from react constMyComponent lazy import . MyComponent.js Context Context提供了数据沿组件树一路传递的方法，而不需要手动赋值给props一级级传递数据在典型的react应用里，数据通过props上下传递，但是对于一些特定的数据，例如全球化参数，主题等，很多组件都需要这些数据，Context提供了在组件中共享数据的方式，而不是在每一级组件中被显式的赋值。 何时使用ContextContext被设计为共享那些被考虑为 global 的数据，例如主题，当前用户等。 tsx Contextletsuspassavaluedeepintothecomponenttree withoutexplicitlythreadingitthrougheverycomponent. Createacontextforthecurrenttheme with light asthedefault .constThemeContext React.createContext light classAppextendsReact.Component render UseaProvidertopassthecurrentthemetothetreebelow. Anycomponentcanreadit,nomatterhowdeepitis. Inthisexample,we repassing dark asthecurrentvalue.return ThemeContext.Providervalue dark Toolbar ThemeContext.Provider Acomponentinthemiddledoesn thaveto passthethemedownexplicitlyanymore.functionToolbar return div ThemedButton div classThemedButtonextendsReact.Component AssignacontextTypetoreadthecurrentthemecontext. ReactwillfindtheclosestthemeProvideraboveanduseitsvalue. Inthisexample,thecurrentthemeis dark .staticcontextType ThemeContext render return Buttontheme this.context 在使用Context之前Context主要用于在很多不同层级组件共享数据，需要小心使用，因为它使组件重用变的困难。 如果仅仅是想避免在多级组件中传递数据，componentcomposition提供了一个更简单的解决方案 API React.createContext typescriptconstMyContext React.createContext defaultValue 创建一个 Context 对象，当订阅了这个Context对象的组件被渲染时，会从组件树中最靠近的Provider读到实时的Context值。 Context.Provider typescript MyContext.Providervalue somevalue 每个Context对象需要和Provider组件配合使用，帮助子组件订阅Context对象的变化。属性 value 的值会被所有订阅了这个context的子组件使用。一个Provider可以被连接到多个子组件。当Provider的属性value发生变化时，所有被Provider包括的消费组件会被重新render。这种重新render不被 shouldComponentUpdate 限制。新旧值的变化和 Object.is 使用了相同的算法。 Class.contextType typescriptclassMyClassextendsReact.Component componentDidMount letvalue this.context performaside effectatmountusingthevalueofMyContext componentDidUpdate letvalue this.context ... componentWillUnmount letvalue this.context ... render letvalue this.context rendersomethingbasedonthevalueofMyContext MyClass.contextType MyContext contextType属性可以被使用Context对象赋值，你可以使用this.context来消费上下文数据，this.context可以在任意声明周期，甚至是render中使用。 这个api只可以订阅单个Context对象，如果需要从多个中获取，参考 ConsumingMultipleContexts 如果你有使用实验中的类属性语句，你可以使用静态类属性来初始化Context。 typescriptclassMyClassextendsReact.Component staticcontextType MyContext render letvalue this.context rendersomethingbasedonthevalue Context.Consumer tsx MyContext.Consumer value rendersomethingbasedonthecontextvalue MyContext.Consumer 这是一个订阅Context变化的react组件，可以帮助我们在函数式组件中使用上下文。子组件必须是一个function，这个function接受一个Context的当前值为参数而且返回一个React元素，这个值会和组件树中最近的Provider值相同。 Context.displayNameContext对象接受一个 displayName 字符串属性，ReactDevTools使用这个字符串来显示Context。例如 tsxconstMyContext React.createContext somevalue MyContext.displayName MyDisplayName MyContext.Provider MyDisplayName.Provider inDevTools MyContext.Consumer MyDisplayName.Consumer inDevTools 示例 动态Context一个更复杂的动态Context的例子如下，主要思路是将Provider的属性value放入组件的state。 theme context.js exportconstthemes light foreground 000000 ,background eeeeee , ,dark foreground ffffff ,background 222222 , , exportconstThemeContext React.createContext themes.dark defaultvalue themed button.js import ThemeContext from . theme context classThemedButtonextendsReact.Component render letprops this.props lettheme this.context return button ...props style backgroundColor theme.background ThemedButton.contextType ThemeContext exportdefaultThemedButton app.js import ThemeContext,themes from . theme context importThemeTogglerButtonfrom . theme toggler button classAppextendsReact.Component constructor props super props this.toggleTheme this.setState state theme state.theme themes.dark themes.light themes.dark, Statealsocontainstheupdaterfunctionsoitwill bepasseddownintothecontextproviderthis.state theme themes.light,toggleTheme this.toggleTheme, render Theentirestateispassedtotheproviderreturn ThemeContext.Providervalue this.state Content ThemeContext.Provider functionContent return div ThemeTogglerButton div ReactDOM.render App ,document.root 订阅多个Context为了保持Context渲染速度，React需要保持每个Context在树中是分开的节点。 Themecontext,defaulttolightthemeconstThemeContext React.createContext light Signed inusercontextconstUserContext React.createContext name Guest , classAppextendsReact.Component render const signedInUser,theme this.props Appcomponentthatprovidesinitialcontextvaluesreturn ThemeContext.Providervalue theme UserContext.Providervalue signedInUser Layout UserContext.Provider ThemeContext.Provider functionLayout return div Sidebar Content div AcomponentmayconsumemultiplecontextsfunctionContent return ThemeContext.Consumer theme UserContext.Consumer user ProfilePageuser user theme theme UserContext.Consumer ThemeContext.Consumer ErrorBoundaries 在过去，组件内的js错误通常会破坏组件内部的状态，并且在下一次render时报错，而且react没有提供一种方式从错误中恢复。 介绍部分UI代码的错误不应该破坏掉整个APP。为了解决这个问题，React16引入了一个新的概念 errorboundary 。ErrorBoundaries是一个react组件，用于处理子组件树中所有的js错误，记录这些错误，并且显示一个fallback页面，而不是让整个组件树崩溃，ErrorBoundaries处理所有在render，LifeCycle，constructors中注意 ErrorBoundaries无法捕捉这些错误1.事件处理。2.异步代码。3.服务端渲染。4.ErrorBoundaries自身的异常。当一个类组件，定义了方法 staticgetDerivedStateFromError 或者 componentDidCatch 时会被认为是一个ErrorBoundary组件。使用 staticgetDerivedStateFromError 来render一个发生异常时的UI，使用 componentDidCatch 来记录错误信息。 typescriptclassErrorBoundaryextendsReact.Component constructor props super props this.state hasError false staticgetDerivedStateFromError error UpdatestatesothenextrenderwillshowthefallbackUI.return hasError true componentDidCatch error,errorInfo YoucanalsologtheerrortoanerrorreportingservicelogErrorToMyService error,errorInfo render if this.state.hasError YoucanrenderanycustomfallbackUIreturn h1 Somethingwentwrong. h1 returnthis.props.children 然后你可以在普通组件使用 tsx ErrorBoundary MyWidget ErrorBoundary ErrorBoundaries和trycatch相同的工作方式，但是仅类组件可以作为ErrorBoundaries。实践中，大部分情况下，会定义一个ErrorBoundaries然后在整个应用中使用。 何处使用可以在整个应用外层使用，提示somethingiserror类似服务端处理的方式。也可以在限定范围使用，防止异常让整个应用崩溃。 捕捉错误的新方式在引入ErrorBoundaries之前，React团队进行过讨论，因为在某些场景，白屏可能比显示错误的信息更合适，例如支付应用，聊天应用等。因此需要根据不同的场景考虑如何使用。 ForwardingRefs RefFowarding是一个用户把ref转发绑定到子元素上的技术手段，对大部分应用组件来说不会用到，但是对于一些类库组件确可能很有用。 ForwardingrefstoDOMcomponents考虑一个 FancyButton 组件，渲染一个元素的dom元素如下 tsxfunctionFancyButton props return buttonclassName FancyButton props.children button React组件隐藏了自己的实现细节，其他使用FancyButton的组件一般不需要内部button组件的ref。这是好的设计，因为能过阻止其他组件过度依赖内部的DOM结构。但是一些应用层级的组件可能倾向于向使用传统的DOM一样使用这些组件，用于管理焦点，选中，动画等。refforward是一个可选的特性，让组件可以获取到自己的ref并传递给下级子组件。例如 tsxconstFancyButton React.forwardRef props,ref buttonref ref className FancyButton props.children button YoucannowgetarefdirectlytotheDOMbutton constref React.createRef FancyButtonref ref Clickme FancyButton 通过这种方式，使用FancyButton的组件，可以直接获取到内部Button的ref。1.我们使用React.createRef创建了一个Reactref，并将它赋值给ref变量。2.通过制定JSX的属性，我们将ref传递给FancyButton组件。3.React传递ref通过调用方法 props,ref ...。4.我们将ref下放绑定到button。5.当ref被指定后，ref.current会被指到buttonDOM节点。第二个参数ref仅在使用React.forwardRef中可以使用，普通的函数组件或者类组件无法获取到ref参数。refforward不限于原生DOM元素，react元素同样可以。 Fragments React中可能会遇到一个组件系统返回多个元素的场景，使用Framents帮助我们返回多个元素而不需要给DOM添加额外的节点。 tsxrender return React.Fragment ChildA ChildB ChildC React.Fragment 动机一个常见的场景是返回多个元素，例如 tsxclassTableextendsReact.Component render return table tr Columns tr table Colums 需要返回多个td来渲染页面，代码可能这样写 tsxclassColumnsextendsReact.Component render return div td Hello td td World td div 但是这会像DOM中添加div导致失效。 用法 tsxclassColumnsextendsReact.Component render return React.Fragment td Hello td td World td React.Fragment 于是我们这样使用。 简写 tsxclassColumnsextendsReact.Component render return td Hello td td World td 使用 可以有相同的效果，唯一的区别是不支持key属性。 带key属性的Framentskey是Frament唯一支持的属性。 Higher OrderComponents 高阶组件是复用组件逻辑的推荐技术，HOCs并不是ReactAPI的一部分，他是React生态中出现的模式。具体来说， 高阶组件是一个方法，接受一个组件作为参数，返回另外一个组件 。 tsxconstEnhancedComponent higherOrderComponent WrappedComponent 一般组件将props转换成UI，但高阶组件是将一个组件转换成另一个组件。高阶组件在React的第三方库中普遍存在，比如Redux s的connect。 使用HOC解决横切关注点问题Cross CuttingConcerns 横切关注点，部分关注点横切程序中的多个模块，既在多个模块中都有他，他们既被称为横切关注点，一个典型的例子就是日志系统。我们之前使用minix处理这个问题，但是后来意识到带来的问题比解决的问题更多。在react中组件是主要的重用单位，但是你会发现一些奇怪的情况，传统组件无法处理。例如下面的CommentList组件，订阅一个外部数据源，然后渲染一个评论列表。 tsxclassCommentListextendsReact.Component constructor props super props this.handleChange this.handleChange.bind this this.state DataSource issomeglobaldatasourcecomments DataSource.getComments componentDidMount SubscribetochangesDataSource.addChangeListener this.handleChange componentWillUnmount CleanuplistenerDataSource.removeChangeListener this.handleChange handleChange Updatecomponentstatewheneverthedatasourcechangesthis.setState comments DataSource.getComments render return div this.state.comments.map comment Commentcomment comment key comment.id div 集成其他库React能在任何web应用中使用，这个主题集中于React和其他类似于jQuery的集成，相同的idea也可以用于React组件和其他已存在代码的集成上。 与基于操作DOM的其他插件集成React对不由React创建的DOM元素的变化没有察觉，React的更新依赖于它自身的内部抽象，如果相同的DOM被其他的库改变，React会陷入困惑而且不会恢复。这不意味着无法或者很难将React和以其他方式影响DOM的方式相结合，只是你需要留意做的事情。最简单的避免冲突的方式是在更新状态时阻止React组件。你可以渲染一个React没有理由去更新的元素，例如空div div 如何解决问题 jsxclassSomePluginextendsReact.Component componentDidMount this. el this.el this. el.somePlugin componentWillUnmount this. el.somePlugin destroy render return divref el this.el el 和Backbone的集成内容跳过。 深入了解JSX本质上讲，JSX只是提供了一种语法糖，实际上是 React.createElement component,props,...children 方法。JSX代码 jsx MyButtoncolor blue shadowSize 2 ClickMe MyButton 编译成 javascriptReact.createElement MyButton, color blue ,shadowSize 2 , ClickMe 也可以使用自包含，没有子元素的标签 jsx divclassName sidebar 编译成 javascriptReact.createElement div , className sidebar 指定ReactElement类型JSX标签首字母大写时，即表示这是一个Reactelement类型。首字母大写类型的JSX标签指向一个React组件，这些标签会直接编译成名称变量，所以如果你使用JSX Foo 表达式， Foo 必须在作用域中。 React必须在作用域中因为JSX编译调用React.createElement，React库必须在JSX代码的作用域中，例如，下面代码中的两个import都是有必要的，尽管React和CustomButton没有在JavaScript代码中直接使用到。 jsximportReactfrom react importCustomButtonfrom . CustomButton functionWarningButton returnReact.createElement CustomButton, color red ,null return CustomButtoncolor red 如果没有使用JavaScript编译工具来加载React，而是直接使用的 script 标签，那React已经在全局作用域中。 使用.符号同样可以使用dot notaion符号来引用React组件，这样可以方便与使用单个模块来导出多个React组件，例如如果 MyComponents.DatePicker 是一个组件，你可以在JSX中直接这样使用 jsximportReactfrom react constMyComponents DatePicker functionDatePicker props return div Imaginea props.color datepickerhere. div functionBlueDatePicker return MyComponents.DatePickercolor blue 用户定义组件必须大写首字母当一个元素类型使用小写字母开头时，它指向的时内置组件，例如 div 或者 span ，内置组件在传递给createElement时是字符串的形式，例如 div 或者 span ，但是首字母大写的组件传递给createElement时是React.createElement Foo 的形式，所以对应的组件必须要有定义，或者从其他文件中引入。推荐使用大写开头来命名组件，如果已经有了小写开头的组件，建议赋值给大写开头的变量后再使用。 在运行时指定类型不能使用表达式作为React元素的类型，如果你想使用表达式作为元素类型，只需要将表达式的值赋给一个大写字母开头的变量。例如 jsximportReactfrom react import PhotoStory,VideoStory from . stories constcomponents photo PhotoStory,video VideoStory functionStory props Wrong JSXtypecan tbeanexpression.return components props.storyType story props.story 如下修复 jsximportReactfrom react import PhotoStory,VideoStory from . stories constcomponents photo PhotoStory,video VideoStory functionStory props Correct JSXtypecanbeacapitalizedvariable.constSpecificStory components props.storyType return SpecificStorystory props.story JSX中的属性有几个不同的方式在JSX中指定属性 使用JavaScript表达式作为属性可以使用JavaScript表达式作为属性，使用 包围，例如 jsx MyComponentfoo 1 2 3 4 if 语句和 for 循环在JavaScript中并不是表达式，因此不能再JSX中直接使用，取而代之的，你可以这样使用 jsxfunctionNumberDescriber props letdescription if props.number 2 0 description strong even strong else description i odd i return div props.number isan description number div 字符串可以直接在属性中使用字符串，以下两种表达是相同的 jsx MyComponentmessage helloworld MyComponentmessage helloworld 当直接使用字符串是，他的值是HTML unescaped，下面两种表示相同 jsx MyComponentmessage lt 3 MyComponentmessage 3 属性的默认值是”True“如果你没有给属性赋予任何值，那它的值将会是 true ，以下两中表达相同 jsx MyTextBoxautocomplete MyTextBoxautocomplete true 扩展属性如果你已经有了一个属性对象，你想在JSX中使用，可以使用 ... 作为扩展操作来传递整个属性对象，下面两个表达相同 jsxfunctionApp1 return GreetingfirstName Ben lastName Hector functionApp2 constprops firstName Ben ,lastName Hector return Greeting ...props JSX子元素在JSX表达方式中，被标签包围的内容，会被构造成一个特色的属性 props.children 。有以下几种不同的方式在处理子元素 字符串可以在标签中放置一个字符串， props.children 也会被指定成这个字符串，这在很多内置的HTML元素中会用到。 jsx MyComponent Helloworld MyComponent 这是一种可用的表达形式， MyComponent 组件的 props.children 会简单的变成字符串 Helloworld 字符串中的换行会被移除。 JSX子元素你可以提供更多的JSX元素作为子组件，在展示一些嵌套时很有用 jsx MyContainer MyFirstComponent MySecondComponent MyContainer 你也能混合几种不同类型的子元素，例如JSX元素和字符串元素，他们像HTML一样组合在一起。 JSX div Hereisalist ul li Item1 li li Item2 li ul div React组件也可以返回一个元素数组。 jsxrender Noneedtowraplistitemsinanextraelement return Don tforgetthekeys likey A Firstitem li , likey B Seconditem li , likey C Thirditem li , JavaScript表达式作为子元素你可以使用JavaScript表达式作为子元素，只需要用 来包含，例如以下两种表达相同 jsx MyComponent foo MyComponent MyComponent foo MyComponent 在用于渲染未知长度的列表时经常用到。 jsxfunctionItem props return li props.message li functionTodoList consttodos finishdoc , submitpr , nagdantoreview return ul todos.map message Itemkey message message message ul JavaScript表达式也能和其他类型混合，例如 jsxfunctionHello props return div Hello props.addressee div 方法作为子组件通常来说，JSX表达式会被计算为字符串，React元素，一些元素的列表等，但是 props.children 和其他属性一样工作，可以被传递任何数据，例如 jsxfunctionRepeat props letitems for leti 0 i props.numTimes i items.push props.children i return div items div functionListOfTenThings return RepeatnumTimes 10 index divkey index Thisisitem index inthelist div Repeat Booleans，Null和Undefined会被忽视 false ， null ， undefined 和 true 是不可用的子元素，他们不会被渲染，这些Jsx表达式会有相同的结果 jsx div div div div false div div null div div undefined div div true div 这在有条件的渲染React组件时经常用到，例如下面的 Header 只有在 showHeader 时 true 时渲染 jsx div showHeader Header Content div 注意，这对一些可转化成false的表达式不适用，例如数字0。如果你想渲染这些类型的数据，可以将他们转化成string，例如 jsx div MyJavaScriptvariableis String myVariable . div 性能优化React使用了很聪明的技术来优化更新DOM的次数，对大部分应用来说，使用React不用做任何事情，也能有优秀的性能。尽管如此，哦我们一人有提升React应用的方法。 使用生产配置来编译如果你在衡量或者试图优化Reactapp的性能，首先要确保你在使用最优的生产编译配置。在默认设置下，React包含了很多有用的警告，这些警告在开发中非常有用，但是他们让React变大更加庞大和缓慢，所以在部署应用时，一定要确保使用的是生产版本。如果你不确定编译设定是否争取，你可以通过安装React开发工具插件来检查。 CreateReactApp如果你的应用是使用CreateReactApp脚手架建设的，执行 shellnpmrunbuild 这会帮你编译应用的生产版本，这是你在发布前唯一需要执行的操作。 Signle FileBuilds我们提供编译版本的React和ReactDom作为单个文件 js scriptsrc https unpkg.com react 16 umd react.production.min.js script scriptsrc https unpkg.com react dom 16 umd react dom.production.min.js script webpackWebpackv4 会自动最小化你的代码，当设置成 production 模式时。 jsconstTerserPlugin require terser webpack plugin module.exports mode production ,optimization minimizer newTerserPlugin additionaloptionshere , , 记住仅在 production 编译模式下需要这样设定，在开发环境下请不要使用 TerserPlugin ，因为这会隐藏React的提醒，而且让编译变得缓慢。 使用ChromePerformaceTab可视化组件装载过程在开发模式下，使用Chrome的性能工具，可以讲组件如何加载，更新，卸载的过程可视化出来 ReactcomponentsinChrometimeline 使用React开发工具来可视化性能 虚拟化长列表如果你的应用需要渲染一个长列表 几百或上千行 ，我们建议使用”windowing“的技术，这个技术仅会渲染一小部分子集，这能减少DOM节点创建时间。 react window 和 react virtualized 时两个流行的窗口化库，他们提供了集中重用组件来展示列表等数据，你也可以创建你自己的窗口化组件，例如 Twitter 的做法，如果你想给你的组件量身定制的话。 避免调和React构建和维持了一个针对已渲染UI的内部表现，包含了所有你从组件中return的元素，这个表现可以让React仅在必要时才创建和操作DOM元素。当一个组件的属性或者状态改变时，React会计算新的renturn和之前的镜像比较，当不一样时，React会更新Dom。尽管React只更新改变的DOM节点，重渲染依然会花费一些时间，在大部分情况下这不会成为一个问题，但是当这种缓慢可以被察觉到时，你可以通过重载生命周期函数 shouldComponentUpdate 来是实现速度优化。在大多数情况下，你可以通过继承 React.PureComponent 来替代重写 shouldComponentUpdate ，这个继承实际上实现了一个 shouldComponentUpdate 方法，这个方法回浅比较当前和上一个状态的props和state。 ShouldComponentUpdate的执行过程 shouldcomponentupdate 其他当你处理深层嵌套的对象数据时，更新他们可能会事件繁琐的事情，这时可检查 Immer 或 immutability helper 库，这可以在不牺牲性能的同时快速更新到对象。 Portals提供一种方法讲允许子节点渲染到父组件意外的DOM节点。 jsxReactDOM.createPortal child,container 第一个参数是任意可被渲染你的React元素，第二个参数，是一个DOM元素 用法一般来讲，当从组件周昂返回一个元素时，它被挂在与DOM上作为一个子元素，但是有些时候，讲子元素插入到DOM的任意位置也是有用的，一个典型的使用场景便是 Modal ， tooltips 等。 事件冒泡尽管Portal可以在DOM树的任意地方，但是它依然和普通的Reactchild的行为一致，作为一个portal，它仍然在reacttree的原来位置，而无论DOM树是怎样的。这包括事件冒泡，一个事件从portal内部发出，会沿着react树向祖先元素传播。 ProfilerAPI Profiler 可以衡量一个React应用的渲染事件，帮助定位应用中的缓慢部分。注意 Profiling添加了一些额外的部分，所以它在生产模式编译时会被禁用。对与生产下进行探查的需求，React提供了一个特殊的探查版用于打开探查功能， fb.me react profiling 用法一个 Profiler 可以被加在React树的任意地方，来很亮这部分树的渲染耗时。他需要两个属性 id 和 onRender 回调。例如下面探查一个 Navigation 组件的方式 jsxrender App Profilerid Navigation onRender callback Navigation ...props Profiler Main ...props App 探查组件可以嵌套或者并排 jsxrender App Profilerid Navigation onRender callback Navigation ...props Profiler Profilerid Main onRender callback Main ...props Profiler App jsxrender App Profilerid Panel onRender callback Panel ...props Profilerid Content onRender callback Content ...props Profiler Profilerid PreviewPane onRender callback PreviewPane ...props Profiler Panel Profiler App 注意， Profiler 尽管是一个轻量的组件，它仍然应该尽在必要时使用，因为它会添加CPU的开销和内存的负担。 onRenderCallback Profiler 需要一个 onRender 方法，React调用这个方法，每当组件出发更新时，他会收到描述渲染时间的参数 jsxfunctiononRenderCallback id, the id propoftheProfilertreethathasjustcommittedphase, either mount ifthetreejustmounted or update ifitre rendered actualDuration, timespentrenderingthecommittedupdatebaseDuration, estimatedtimetorendertheentiresubtreewithoutmemoizationstartTime, whenReactbeganrenderingthisupdatecommitTime, whenReactcommittedthisupdateinteractions theSetofinteractionsbelongingtothisupdate Aggregateorlogrendertimings... React的调和过程React提供了陈述式的API，让我们不用担心每次更新实际上的变化，这让我们编写一个应用程序变得更容易，但是React如何实现的细节可能不是那么显而易见，这篇文章解释了我们在打造Reactdiffing算法中的选择和决定。 动机当你使用React时，唯一你需要思考的关注点时render方法，在下一个状态或者属性更新时，render方法会返回一个不同的React树，于是React需要解决，如何比较两个树，来最有效率的更新UI。有一些通用的算法来处理将一个树转换成另一个树的问题，但是通常拥有O n3 的复杂度，如果我们使用这个算法，那展示1000个元素，将需要对比百万次，代价过于高昂，取而代之的是，React实现了一个启发式的算法基于以下两个假设 1.两个不同类型的元素会产生不同的树。2.开发者可以通过key属性，表示不同渲染的两个元素是否相同。在实践中，这两个假设被验证是可行的。 Diffing算法当diffing两个树时，React首先比价两个root的元素。 元素类型不相同无论什么时候，当root元素有两个不同的类型时，React会直接干掉旧的树，而且构建一个新树来代替。当销毁一个旧的树时，组件实例会收到 componentWillUnmount 方法，当构造一个新树时，新的DOM节点会被插入到DOM中，组件会收到 componentWillMount 然后收到 componentDidMount ，任何和旧树相关的状态会消失掉。 DOM类型而且类型相同当比较两个ReactDOM元素时，React会关注两边的属性，保留相同的，而仅更新有变化的。 组件类型而且类型相同当一个组件更新时，实例依然时同一个，所以状态会在整个渲染过程中保留，React会更新组件实例的属性，来匹配新的袁术，然后调用实例中的 componentWillReceiveProps 方法和 componentWillUpdate 方法。接下来，render方法会被调用，diff算法递归向下调用。 子元素列表默认的，当递归一个DOM节点的子元素时，React简单的列出两边的list，然后按顺序比较。 Keys为了解决这个问题，React支持key属性。 权衡 Refs和DOM Refs提供了一种访问DOM节点或者React元素的方式在典型的React数据流中， props 是唯一的父组件和子组件沟通的方式。为了改变子元素，你需要使用新的属性重新渲染它。然而，仍然有少数的情况你需要直接修改子元素。 何时使用refs有以下几个最佳实践 管理focus，文本选择，或者媒体播放 触发重要的动画 和第三方DOM库集成除非无法实现，否则请尽量避免使用Ref 不要过度使用你可能会认为ref可以做到任何可能的事请，如果你是这样想的，不妨审慎思考一下，是否有其他途径来实现，尤其是组件状态的层级问题是否有正确的设计。 创建Ref可以使用 React.createRef 来创建Refs，通常在构造函数方法内将React元素赋值给一个实例的 ref 属性。一下是一个实例 jsxclassMyComponentextendsReact.Component constructor props super props this.myRef React.createRef render return divref this.myRef 访问Refs当在 render 方法中绑定ref后，node就可以通过ref的current属性来访问到 jsxconstnode this.myRef.current ref的值取决于node的类别 但ref属性在html元素中使用时，在构造函数调用的 React.createRef 会接收到DOM元素作为他的current属性。 但ref属性在自定义组件中用到时，ref对象会接收到一个组件实例作为他的current属性 你不可以在函数式组件中使用ref属性，因为他们不具备一个实例。以下示例展示了他们的区别 给DOM元素添加REF以下示例使用了 ref 来保存一个DOM节点的引用 jsxclassCustomTextInputextendsReact.Component constructor props super props this.textInput React.createRef this.focusTextInput this.focusTextInput.bind this focusTextInput this.textInput.current.focus render return div inputtype text ref this.textInput inputtype button value Focusthetextinput onClick this.focusTextInput div React会在组件加载时将DOM元素赋值给current属性，而且在卸载时赋予null值，ref的更新发生在 componentDidMount 或者 componentDidUpdate 生命周期函数之前。 给Class类型组件添加ref如果在 CustomerTextInput 上层有类似的逻辑，我们可以使用ref来获取到自定义的input而且调用它的 focusTextInput 方法。 JSXclassAutoFocusTextInputextendsReact.Component constructor props super props this.textInput React.createRef componentDidMount this.textInput.current.focusTextInput render return CustomerTextInputref this.textInput 注意这仅当 CustomTextInput 使用class来声明时才有用 给函数式组件添加REF默认的，我们可能没有办法在一个函数式组件中使用ref属性，因为他们并没有一个实例 jsxfunctionMyFunctionComponent return input classParentextendsReact.Component constructor props super props this.textInput React.createRef render 不会正常工作return MyFunctionComponentref this.textInput 如果你想允许人们获取你的函数式组件的ref，你可能要使用forwardRef或者你可以将他转换成一个类声明的组件。然而，你能在函数式组件的内部使用ref，无论指向一个DOM元素，还是一个类声明的元素。 jsxfunctionCustomTextInput props consttextInput useRef null functionhandleClick textInput.current.focus return div inputtype text ref textInput inputtype button value Focusthetextinput onClick handleClick div 向父组件暴露DOMRefs在极其稀有的场景下，你会想要通过父组件访问其子元素的DOM，这通常时不推荐的，因为这打破的组件封装，但是这有时会很有用，当需要监控focus或者计算子元素的位置和大小时。你可能会给子组件添加ref，但是这不是个好主意，你只能得到一个组件实例，而不是一个DOM节点，而且，这在函数式组件中并不可用。如果你在使用React16.3以上的版本，我们推荐使用 refforwarding ，Refforwarding让组件选项透传出任意子元素的ref作为他们自己的ref，这里是一个实例， intherefforwardingdocumentation 如果你使用的是React16.2或者更低，你需要更复杂的方案来实现，你可以使用 thisalternativeapproach 来使用一个命名的属性显式传递ref。在可能的情况下，我们建议不要透传DOM节点。 回调式RefReact也支持另外一种方式设置ref叫做 callbackrefs ，这种方式给了我们更细粒度控制refs的方法不同于使用createRef创建传递一个ref的属性，传递一个方法，这个方法接受一个dom节点或者有一个react组件实例作为参数，他们可以被保存起来，在任意地方被访问。下面是使用这种方式的一个实例 jsxclassCustomTextInputextendsReact.Component constructor props super props this.textInput null this.setTextInputRef element this.textInput element this.focusTextInput FocusthetextinputusingtherawDOMAPIif this.textInput this.textInput.focus componentDidMount autofocustheinputonmountthis.focusTextInput render Usethe ref callbacktostoreareferencetothetextinputDOM elementinaninstancefield forexample,this.textInput .return div inputtype text ref this.setTextInputRef inputtype button value Focusthetextinput onClick this.focusTextInput div 在上面的例子中，父元素通过传递 CustomTextInput 属性获取到子元素input的ref。 创建REF的注意事项如果你使用行内函数来定义的ref回调，他会在update期间更新两次，第一次传递null再次才传递DOM元素，这是因为每次render都会创建一个新的函数实例，react需要清除旧的ref设置一个新的。你可以通过定义ref回调在一个类上。 渲染属性 主题 renderprop 指的是在React组件间共享数据的方法，通过设置方法作为属性的值拥有 render 属性的组件，会使用 render 属性的方法代理自身的render方法，来进行渲染。 jsx DataProviderrender data h1 Hello data.target h1 ReactRouter , Downshift 和 Formik 库都有使用到render属性。在本文中，我们将进行讨论，为什么render属性是有用的，以及如何编写你自己的。 使用Render属性处理关注点横切问题组件在react中是主要的代码复用单元，但是如何将一个组件的状态和行为共享给其他组件并不总是清晰明确的。例如，下面的组件追踪了webapp的鼠标位置 jsxclassMouseTrackerextendsReact.Component constructor props super props this.handleMouseMove this.handleMouseMove.bind this this.state x 0,y 0 handleMouseMove event this.setState x event.clientX,y event.clientY render return divstyle height 100vh onMouseMove this.handleMouseMove h1 Movethemousearound h1 p Thecurrentmousepositionis this.state.x , this.state.y p div 随着鼠标在屏幕上的移动，组件显示他的横纵坐标在p元素节点中。现在问题是，我们如何在其他组件中重用这种行为，换句话说，如果另外的组件需要知道鼠标位置，我们可以封装这种行为，以便我们轻松的在组件中共享和使用吗。使用renderprops的方案 jsxclassCatextendsReact.Component render constmouse this.props.mouse return imgsrc cat.jpg style position absolute ,left mouse.x,top mouse.y classMouseextendsReact.Component constructor props super props this.handleMouseMove this.handleMouseMove.bind this this.state x 0,y 0 handleMouseMove event this.setState x event.clientX,y event.clientY render return divstyle height 100vh onMouseMove this.handleMouseMove Insteadofprovidingastaticrepresentationofwhat Mouse renders,usethe render proptodynamicallydeterminewhattorender. this.props.render this.state div classMouseTrackerextendsReact.Component render return div h1 Movethemousearound h1 Mouserender mouse Catmouse mouse div 使用其他组件和render的区别很重要的一点是，这种模式叫做 renderprops 并不意味着只能用一个命名为 render 的属性来实现这种模式，实际上，任意属性都可以实现这种技术。我们可以轻松的使用 children 属性来实现它。 注意事项 对于继承React.PureComponent的组件谨慎使用使用render属性会抹除使用React.PureComponent组件的优势，如果你在render属性内创建函数，那每次对props的比较都将不相同。 静态类型检查 严格模式 严格模式是高亮潜在问题的一种方式，像Fragment，StrictMode不会渲染任何可见的UI，它激活了潜在的检查和警告严格模式检查仅在开发模式下游泳，他们对生产编译不会有任何影响你可以在应用的任何部分打开strictmode例如 tsximportReactfrom react functionExampleApplication return div Header React.StrictMode div ComponentOne ComponentTwo div React.StrictMode Footer div 在上面的例子中，严格模式检查不会在 Header 和 Footer 组件中生效，只有 ComponentOne 和 ComponentTwo 以及他们的子元素会应用检查。严格模式会在一下几点有助于我们 定位使用不安全什么周期函数的组件 对遗留stringref的使用进行警告 警告弃用的findDOMNode方法 检测意外的副作用 探测将被废弃的contextapi 定位不安全的生命周期某些生命周期方法在异步react应用中可能是不安全的，然而，如果你的应用使用了第三方库，很难确保这些库是否有使用这些到这些生命周期函数，幸运的是，严格模式会帮助到我们。当严格模式开启时，React会列出所有使用了不安全生命周期的组件，而且在console中打印出来 image 20201118174745768 对遗留stringref的使用进行警告我们知道，react提供了两种使用和关联ref的方法，legacystringrefapi和callbackapi，尽管stringref看上去似乎更方便，但是基于 severaldownsides 我们官方推荐使用callbackref代替stringrefReact16.3添加了第三个选项来使用stringref而没有任何缺陷 jsxclassMyComponentextendsReact.Component constructor props super props this.inputRef React.createRef render return inputtype text ref this.inputRef componentDidMount this.inputRef.current.focus 警告弃用的findDOMNode方法React过去支持findDOMNOde方法来打破抽象，直接找到DOM元素。但是现在有了ref所有实际上我们不再需要该方法。 检测意外的副作用概念上讲，React在完成工作可以分为两个阶段 render阶段 确定需要应用到DOM的修改，在这个阶段，React调用 render 然后和上一次的render结果进行比较 commit阶段 React应用变更到DOM，同时也会调用生命周期方法，像 componentDidMount 和 componentDidUpdate 。 探测将被废弃的contextapi 非受控组件 在大多数情况下，我们建议使用受控组件来实现表单，在受控组件中，表单数据被react组件处理。另外一个选项是非受控组件，表单数据将由DOM自身处理非受控 jsxclassFormextendsComponent handleSubmitClick constname this._name.value dosomethingwith name render return div inputtype text ref input this._name input buttononClick this.handleSubmitClick Signup button div 受控 jsxclassFormextendsComponent constructor super this.state name , handleNameChange event this.setState name event.target.value render return div inputtype text value this.state.name onChange this.handleNameChange div 区别在于是否要将form的value保存到状态中。尽管一个非受控组件会保存DOM的真实数据，在某些时候，这对于集成react和非react代码很有用处，而且这种方式看上去代码更少和更高效，但是，我们仍然建议使用受控组件。 默认值在react渲染生命周期中，元素的 value 属性会覆盖DOM的vaule，但使用一个非受控组件时，你通常希望react特别指定默认值，但是在后续的更新中离开。为了处理这种案例，你可以通过传递 defaultValue 代替传递 value 。组件转载后改变defaultValue将不会更新dom的value。 文件类型的input在html中， inputtype file 让用户可以从他们的设备中选择一个或多个文件。在React中， inputtype file 总是一个非受控组件，因为他的值无法被用户设置，而且不可编程。你可以使用FILEAPI来和文件交互，下面的例子展示了如果通过创建一个DOM节点的ref来在提交前访问文件 jsxclassFileInputextendsReact.Component constructor props super props this.handleSubmit this.handleSubmit.bind this this.fileInput React.createRef handleSubmit event event.preventDefault alert Selectedfile this.fileInput.current.files 0 .name render return formonSubmit this.handleSubmit label Uploadfile inputtype file ref this.fileInput label br buttontype submit Submit button form ReactDOM.render FileInput ,document.getElementById root WebComponents react和 WebComponents 为了处理不同的问题而构造，webcomponent为可复用的组件提供了强封装，但是react提供了一个声明式的库来保持DOM和数据的同步，这两个目标是互补的，作为一个开发者，你可以在你的webcomponent中自由的使用react，或者在React中使用webcomponent。大多数使用react的用户不会使用到webcomponent，但是你可能会想使用，尤其是当你使用第三方的由webcomponent编写的UI组件时。 在react中使用webcomponent jsxclassHelloMessageextendsReact.Component render return div Hello x search this.props.name x search div ","categorie":"React-简介"},{"route":"/docs/frontend/typescript/基础.html","content":" TypeScript技术学习TypeScript是微软出品的语言，是js的超集，添加了类型，接口等特性，使用tsc编译器可以将ts编译成js，实际浏览器和服务器上的仍然是js 特性 ts会做静态类型检查，编译的时候会报错，但是依然会生成编译文件，有配置文件可以修改，让ts在报错情况下不生成js 数据类型js中数据类型分为原始数据类型 布尔，数值，字符串，null，undefined，Symbol 和对象类型 原始类型在ts中的应用1.数值， lettest number 123 2.布尔， lettest boolean true 3.字符串， lettest string xxxxxx 4.Null， lettest null null 5.Undefined， lettest undefined null fontcolor red 注意Null和undefined是所以类型的子类型，也就是其他类型可以被赋值为undefined或者null font 任意值可以使用 Any 声明任意值，可以任意赋值以及调用属性而不会报错 类型推论声明并赋值时，没有指定类型的变量会根据赋值做类型推断，没有赋值的声明会被认为是any 联合类型使用 lettest string number 可以声明联合类型，可以将不同类型的值赋予给联合类型，但是联合类型只能掉用两种类型共有的属性和方法。 交叉类型使用 lettest A B 可以声明交叉类型，交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 对象的类型 接口 一般使用 typescriptinterfacePerson name string age number lettom Person name xxx ,age 19 ts的接口可以定义对象属性，如上定义的接口，在被继承时不能新增属性，也不能减少属性。 可选属性 typescriptinterfacePerson name string age number six string 如上定义的接口，six属性可空 任意类型属性 typescriptinterfacePerons name string age number six string propName string string number 如上定义的接口，可以使用任意属性。需要注意，任意属性的可选类型需要包含已定义属性的类型 只读属性 typescriptinterfacePerons readonlyname string age number six string propName string string number 如上定义的接口，属性 name 为只读属性，不可被重新赋值以及修改。 数组类型 一般使用 typescriptlettest number 1,2,3,4,5 给数组加入任意不符合类型定义的值将会报错 数组泛型 typescriptlettest Array number 1,2,3,4,5 函数类型 函数声明 typescriptfunctiontest x number,y number number returnx y 函数表达式仅对等式右边进行了类型声明，左边使用的实际上是类型推断 typescriptlettest function x number,y number number returnx y 或，对等式两边都进行了类型声明 typescriptlettest x number,y number number function x number,y number number returnx y 使用接口定义 typescriptinterfaceITest x number,y number number lettest ITest test function x number,y number returnx y 可选参数我们使用 表示表示参数可选，但是可选参数后不能有必选参数 typescriptfunctiontest x number,y number,z number number if z undefined returnx y z returnx y 参数默认值当使用默认值时，不受可选参数后不能有必选参数的限制 typescriptfunctiontest x number,y number,z number 1 剩余参数使用 ...rest 的方式获取剩余参数 typescriptfunctiontest x number,...items any 重载Ts会优先匹配前面的定义，因此应该将最精准匹配的放在最前面 typescriptfunctiontest x number number functiontest x string string functiontest x number string number string if typeofx string return xxx return0 类型断言类型断言可以手动指定一个值的类型 typescript值as类型 类型断言的用途1.将联合类型断言为其中一种类型，从而可以访问这个类型特有的属性。但是要注意这种做法可能会在运行时报错。2.将父类型断言为具体的字类型。3.将变量断言成 any 从而可以访问任意属性而不报错，前提是你必须确定该对象上存在这个属性4.将 any 断言成具体的类型 类型断言的限制1.联合类型可以被断言成具体类型2.父类型可以被断言成具体的子类型3.任何类型可以被断言成 any 4. any 可以被断言成人意类型typescript是结构类型系统，类型之间的对比只会比较他们最终的结构，而忽略他们定义时的关系。 typescriptinterfaceAnimal name string interfaceCat name string run void lettom Cat name tom ,run console.log run letanimal Animal tom 因为Animal和Cat项目兼容，所以可以使用实现了Cat接口的数据对象给声明为Animal的对象赋值，实际上，Animal和Cat与下面的实现相同 typescriptinterfaceAnimal name string interfaceCatextendsAnimal run void 当 Animal 兼容 Cat 时，他们就可以互相之间进行类型断言。 双重断言 typescriptfooasanyasother 将任意类型断言成 any 再将 any 断言成其他类型，这在ts编译阶段通常不会报错，但是这种做法其实跳过了类型，需要谨慎使用 类型断言和类型转换类型断言只是用于TypeScript编译阶段，实际并不会影响对象的类型，在编译成js时类型断言语句会被删除，类型转换需要使用类型转换语句。 声明文件当使用第三方库时，我们需要引用他的声明文件，才能获得相应的代码补全，接口提示等功能。声明文件必需以 .d.ts 为后缀。 书写声明文件1. declarevar 声明全局变量2. declarefuncton 声明全局方法3. declareclass 声明全局类4. declareenum 声明全局枚举类型5. declarenamespace 声明全局对象6. interface和type 声明全局类型 EMCAScript内置对象 EMCAScript标准的内置对象 Boolean Error Date RegExp 等。更多的内置对象，可以查看 MDN的文档 。而他们的定义文件，则在 TypeScript核心库的定义文件 中。 DOM和BOM内置对象 Document HTMLElement Event NodeList 等。常用 typescriptletbody HTMLElement document.body letallDiv NodeList document.querySelectorAll div document.addEventListener click ,function e MouseEvent Dosomething 类型别名类型别名用来给一个类型取一个新名字 typescripttypeName string typeNameResolver string typeNameOrResolver Name NameResolver functiongetName n NameOrResolver Name if typeofn string returnn else returnn 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个 typescripttypeEventNames click scroll mousemove functionhandleEvent ele Element,event EventNames dosomething 元组数组合并来相同类型的对象，而元组合并了不同类型的对象。 typescriptlettom number,string 1, xxx 越界的元素当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型 typescriptlettom string,number tom Tom ,25 tom.push male tom.push true 编译报错 枚举 简单的枚举定义 typescriptenumDays Sun,Mon,Tue,Wed,Thu,Fri,Sat 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射 typescriptconsole.log Days Sun 0 trueconsole.log Days Mon 1 trueconsole.log Days Tue 2 trueconsole.log Days Sat 6 trueconsole.log Days 0 Sun trueconsole.log Days 1 Mon trueconsole.log Days 2 Tue trueconsole.log Days 6 Sat true 手动赋值我们可以给枚举值手动赋值，值会从手动赋值到数字开始递增，所以要注意覆盖问题。 typescriptenumDays Sun 3,Mon 1,Tue,Wed,Thu,Fri,Sat console.log Days Sun 3 trueconsole.log Days Wed 3 trueconsole.log Days 3 Sun falseconsole.log Days 3 Wed true TypeScript不会检查手动赋值到覆盖问题，所以需要格外注意。手动赋值的枚举项可以不是数字 typescriptenumDays Sun 7,Mon,Tue,Wed,Thu,Fri,Sat any S 手动枚举可以赋值为负数或者小数，后续未手动赋值的项目依然会以 1 为步长递增 typescriptenumDays Sun 7,Mon 1.5,Tue,Wed,Thu,Fri,Sat console.log Days Sun 7 trueconsole.log Days Mon 1.5 trueconsole.log Days Tue 2.5 trueconsole.log Days Sat 6.5 true 常数项和计算所得项枚举项有两种类型， 常数项 和 计算所得项 前面列举的都是常数项，计算所得项如下 typescriptenumColor Red,Green,Blue blue .length 如果在计算所得项后有未手动赋值的枚举项，将会因为无法得到初始值报错 typescriptenumColor Red red .length,Green,Blue index.ts 1,33 errorTS1061 Enummembermusthaveinitializer. index.ts 1,40 errorTS1061 Enummembermusthaveinitializer. 常数枚举常数枚举是使用 constenum 定义的枚举类型 typescriptconstenumDirections Up,Down,Left,Right letdirections Directions.Up,Directions.Down,Directions.Left,Directions.Right 常数枚举和普通枚举的区别是，它会在编译阶段删除，而且不能包括计算成员 外部枚举外部枚举是使用 delareenum 定义的枚举类型 typescriptdeclareenumDirections Up,Down,Left,Right letdirections Directions.Up,Directions.Down,Directions.Left,Directions.Right 外部枚举通常出现在声明语句中。 类传统方法中，使用构造函数创建类，通过原型链实现继承。在ES6中，我们有了class。用法与C 等面向对象语言一致。 补充 Omit3.5版本之后，TypeScript在lib.es5.d.ts里添加了一个Omit T,K 帮助类型。Omit T,K 类型让我们可以从另一个对象类型中剔除某些属性，并创建一个新的对象类型 typescripttypeUser id string name string email string typeUserWithoutEmail Omit User, email 等价于 typeUserWithoutEmail id string name string ","categorie":"前端-TypeScript-基础"},{"route":"/docs/react/最佳实践/从零构建一个React项目.html","content":" 从零构建一个React项目 Start新建文件夹，执行 shellyarninit 安装基础包 shellyarnaddreactreact domyarnaddwebpackwebpack cli 简单编写代码1.添加src文件夹2.在src添加index.js文件3.index.js文件内容 typescriptimportReactDomfrom react dom ReactDom.render xxx ,document.getElementById root 4.添加webpack.config.js配置简单配置webpack typescriptmodule.exports entry . src index.js ,output filename . index.js 5.编辑package.json文件，添加编译命令 typescript scripts build webpack , 6.命令行执行编译命令 shellyarnrunbuild 完成最简版本前端项目，编译出index.js手动创建index.html添加对该js的引用 index.html html html body divid root div scriptsrc . index.js script body html 使用第一个插件简单版需要手动创建html和手动引用资源文件，显然我们并不想这么干，在css，图片，等资源丰富之后，一个个手动新增并不现实，于是我们需要一个插件帮助在build阶段实现自动输出index.html。 使用HtmlWebpackPlugin插件1.安装 shellyarnadd devhtml webpack plugin 2.在src下创建index.html模板文件，内容如下 html html body divid root div body html 3.配置使用 typescriptconstHtmlWebpackPlugin require html webpack plugin module.exports entry . src index.js ,output filename . index.js ,plugins newHtmlWebpackPlugin template . src index.html 4.再次build在dist文件夹可以看到index.js和index.html文件，使用浏览器打开index.html出现如我们所期望的内容。 更近一步简单项目我们使用了ReactDom挂载简单的内容到指定Dom容器中，显然我们实际工作中并不会如此简单，更近一步的，我们需要做到 使用TypeScript 使用JSX 使用webpackdevserver 引用CSS文件 引用静态图片文件 使用JSX1.创建 src app 文件夹，新建 index.js 文件，内容如下 typescriptimport Component from react classIndexextendsComponent render return xxxx exportdefaultIndex 2.在 src index.js 中使用 jsx typescriptimportReactDomfrom react dom importAppfrom . app index ReactDom.render App ,document.getElementById root 3.执行 yarnrunbuild 这时会报错，因为 jsx 作为js的语法扩展，并不被原生js支持，我们需要配置webpack，使用 babel loader 4.安装 yarnadd devbabel loader babel preset react 5.配置webpack.config.js typescriptmodule rules test . ts js tsx ,use loader babel loader ,options presets babel preset react ,exclude node_modules , , , , 6.执行 yarnrunbuild 可以看到成功编译7.打开index.html文件，页面空白，控制台报错 reactisnotdefined 发现编译后没有React库8.修改 src index.js ，添加对React的引用 typescriptimportReactDomfrom react dom importReactfrom react importAppfrom . app index ReactDom.render App ,document.getElementById root 9.修改 src app index.js ，添加对React的引用 typescriptimportReact, Component from react classIndexextendsComponent render return div xxxxxxxxxxx div exportdefaultIndex 10.再次编译后，提示成功，打开html页面，显示正常。 使用TypeScript1.修改 src app index.js 文件名后缀为 index.tsx 2.修改 src app index.tsx 内容为 typescriptimportReact, Component from react interfaceIndexProps name string age number classIndexextendsComponent IndexProps render return div xxxxxxxxxxx div exportdefaultIndex 3.修改 src index.js 文件名后缀为 index.tsx 4.添加插件 yarnadd devtypescriptawesome typescript loadersource map loader 5.修改webpack配置，添加Loader typescript test .tsx ,loader awesome typescript loader , 添加resolve配置，实现webpack对 tsx 后缀文件的识别 typescriptresolve extensions .tsx , .ts , .js , 6.添加 tsconfig.json 配置typescript编译器选项 typescript compilerOptions outDir . dist , sourceMap true, noImplicitAny true, module commonjs , target es5 , esModuleInterop true, jsx react , include src , 注意，不添加esModuleInterop会导致一些没有默认导出的外部模块报错7.执行编译，如期报错，因为我们在使用组件时没有给组件添加属性。8.修改 src index.tsx 文件内容如下 typescriptimportReactDOMfrom react dom importReactfrom react importAppfrom . app index ReactDOM.render Appage 1 name xxx ,document.getElementById root 9.再次执行 yarnrunbuild ，编译成功，打开index.html显示正常。10.对于引入css可能会出现报错，因为没有导出，可以添加 global.d.ts 文件，内容如下 typescriptdeclaremodule .css declaremodule .scss declaremodule .png 11.修改 tsconfig.json 的配置 typescript compilerOptions outDir . dist , sourceMap true, noImplicitAny true, module commonjs , target es5 , esModuleInterop true, jsx react , include src , global.d.ts , 使用webpackdevserver我们使用开发服务器代替打开html文件的方式1.添加包 yarnadd devwebpack dev server 2.在 package.json 添加执行脚本 typescript start webpack dev server 3.配置 webpack.config.js 文件新增 devServer 节点 typescriptdevServer contentBase path.join __dirname, dist ,compress true,port 9000 4.使用命令 yarnstart 启动开发环境。访问 http localhost 9000 看到页面正常显示，修改文件，自动编译和刷新5.这时默认只有localhost的可以访问，如果是在远程机开发，需要如下修改，然后才能使用远程机ip加端口访问 typescriptdevServer host 0.0.0.0 ,contentBase path.join __dirname, dist ,compress true,port 9000 这个配置几乎没有遇到坑点。 引入样式我们需要事项以下目的 1.在组件中使用 import myclassname from .. index.scss 导入和使用样式。2.编译后，生成单独的样式文件步骤 1.新增 src style.scss 样式文件，并编写样式内容如下 typescript.test text align center width 100 2.修改 src app index.tsx 文件，添加引入和使用样式的代码 typescriptimportReact, Component from react importStylesfrom .. style.scss interfaceIndexProps name string age number classIndexextendsComponent IndexProps render return divclassName Styles.test xxxxxxxxxxx div exportdefaultIndex 3.执行 yarnstart 报错，提示没有处理改类型文件的Loader。4.安装Loader yarnadd devcss loadersass loaderstyle loader 5.修改webpack配置文件，添加Loader typescript test .css scss ,use style loader , loader require.resolve css loader ,options modules true, , sass loader 将Sass编译成CSS，默认使用NodeSass 6.执行 yarnstart 提示成功，打开浏览器可以看到文字已居中，但是我们会发现，并没有使用单独的css文件，而是通过js创建的css，这不利于生产上，用户对资源的缓存，比如我们修改的js，但是没有修改样式，最终编译出来的js有变化，客户端会重新加载而不使用缓存，所以我们需要分离js和css。7.安装插件 yarnadd devmini css extract plugin 修改webpack配置，需要修改Loader以及添加插件 替换style loader typescript test .css scss ,use loader MiniCssExtractPlugin.loader,options publicPath .. , loader require.resolve css loader ,options modules true, , sass loader 将Sass编译成CSS，默认使用NodeSass 添加plugins typescriptplugins newHtmlWebpackPlugin template . src index.html ,newMiniCssExtractPlugin filename name .css ,chunkFilename id .css , 注意需要在开头引入插件 constMiniCssExtractPlugin require mini css extract plugin 8.再次执行 yarnstart 页面成功运行，并且在网络请求中可以看到有单独的css文件。坑点 1.当前已经不需要使用 typings for css modules loader 来做在tsx中应用css文件的功能，只需要修改css loader的options添加 modules true 即可 使用静态图片我们希望实现1.图片资源可以在组件中被import2.图片资源可以这样使用 typescriptimportmyimgfrom .. asset test.png .... imgsrc myimg 步骤 1.修改 src app index.tsx 文件，添加图片引用和使用代码 typescriptimportReact, Component from react importStylesfrom .. style.scss importbaiduImgfrom .. asset baidu logo.png interfaceIndexProps name string age number classIndexextendsComponent IndexProps render return divclassName Styles.test imgsrc baiduImg xxxxxxxxxxx div exportdefaultIndex 2.执行 yarnstart 报错，提示无法处理该类型文件。3.添加 file loader typescriptyarnadd devfile loader 4.修改webpack配置，添加Loader typescript loader require.resolve file loader , Exclude js filestokeep css loaderworkingasitinjects itsruntimethatwouldotherwisebeprocessedthrough file loader. Alsoexclude html and json extensionssotheygetprocessed bywebpacksinternalloaders.exclude . js mjs jsx ts tsx css scss , .html , .json ,options name name . hash 12 . ext , , , 5.再次执行 yarnstart 页面正常加载，图片显示。未发现坑点。考虑性能问题，小于8k的图片我们可能不希望浏览器发起http请求去获取，这时我们可以使用 url loader typescript test . gif png svg eot otf ttf woff woff2 ,use loader url loader ,options limit 8192, , 注意，必须配合 file loader 使用，虽然不会报错，但是生产的base64无法被展示为图片。 typescript loader require.resolve file loader ,exclude . js mjs jsx ts tsx css scss svg , .html , .json ,options name name . hash 12 . ext , , , 其他1.开启 sourcemap ，在开发阶段方便调试代码。需修改webpack配置如下 typescriptmodule.exports entry . src index.tsx ,output filename . index.js ,devtool source map ,..... 结束如此我们大致实现了 create react app 帮助实现的基本功能，但是我们观察create帮助创建的项目，会发现，仍然有很多插件和实现我们没有使用到过，在下面的开发中，我们尝试构建一个完整的复杂前端项目，发现问题的同时，理解create中的其他插件和操作。 手撸一个业务系统我们尝试开发一个真实可用的系统，在实践中完善我们的工具链和架构 目标产品 FAQ1.当我们通过NGINX转发时，一般会设定basepath用作转发，这时如果是通过 create react app 创建的react应用，可以修改 package.json 配置 homepage 节点","categorie":"React-最佳实践-从零构建一个React项目"}]
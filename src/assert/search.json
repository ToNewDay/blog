[{"route":"/docs/frontend/typescript/基础.html","content":" TypeScript技术学习TypeScript是微软出品的语言，是js的超集，添加了类型，接口等特性，使用tsc编译器可以将ts编译成js，实际浏览器和服务器上的仍然是js 特性 ts会做静态类型检查，编译的时候会报错，但是依然会生成编译文件，有配置文件可以修改，让ts在报错情况下不生成js 数据类型js中数据类型分为原始数据类型 布尔，数值，字符串，null，undefined，Symbol 和对象类型 原始类型在ts中的应用1.数值， lettest number 123 2.布尔， lettest boolean true 3.字符串， lettest string xxxxxx 4.Null， lettest null null 5.Undefined， lettest undefined null fontcolor red 注意Null和undefined是所以类型的子类型，也就是其他类型可以被赋值为undefined或者null font 任意值可以使用 Any 声明任意值，可以任意赋值以及调用属性而不会报错 类型推论声明并赋值时，没有指定类型的变量会根据赋值做类型推断，没有赋值的声明会被认为是any 联合类型使用 lettest string number 可以声明联合类型，可以将不同类型的值赋予给联合类型，但是联合类型只能掉用两种类型共有的属性和方法。 交叉类型使用 lettest A B 可以声明交叉类型，交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 对象的类型 接口 一般使用 typescriptinterfacePerson name string age number lettom Person name xxx ,age 19 ts的接口可以定义对象属性，如上定义的接口，在被继承时不能新增属性，也不能减少属性。 可选属性 typescriptinterfacePerson name string age number six string 如上定义的接口，six属性可空 任意类型属性 typescriptinterfacePerons name string age number six string propName string string number 如上定义的接口，可以使用任意属性。需要注意，任意属性的可选类型需要包含已定义属性的类型 只读属性 typescriptinterfacePerons readonlyname string age number six string propName string string number 如上定义的接口，属性 name 为只读属性，不可被重新赋值以及修改。 数组类型 一般使用 typescriptlettest number 1,2,3,4,5 给数组加入任意不符合类型定义的值将会报错 数组泛型 typescriptlettest Array number 1,2,3,4,5 函数类型 函数声明 typescriptfunctiontest x number,y number number returnx y 函数表达式仅对等式右边进行了类型声明，左边使用的实际上是类型推断 typescriptlettest function x number,y number number returnx y 或，对等式两边都进行了类型声明 typescriptlettest x number,y number number function x number,y number number returnx y 使用接口定义 typescriptinterfaceITest x number,y number number lettest ITest test function x number,y number returnx y 可选参数我们使用 表示表示参数可选，但是可选参数后不能有必选参数 typescriptfunctiontest x number,y number,z number number if z undefined returnx y z returnx y 参数默认值当使用默认值时，不受可选参数后不能有必选参数的限制 typescriptfunctiontest x number,y number,z number 1 剩余参数使用 ...rest 的方式获取剩余参数 typescriptfunctiontest x number,...items any 重载Ts会优先匹配前面的定义，因此应该将最精准匹配的放在最前面 typescriptfunctiontest x number number functiontest x string string functiontest x number string number string if typeofx string return xxx return0 类型断言类型断言可以手动指定一个值的类型 typescript值as类型 类型断言的用途1.将联合类型断言为其中一种类型，从而可以访问这个类型特有的属性。但是要注意这种做法可能会在运行时报错。2.将父类型断言为具体的字类型。3.将变量断言成 any 从而可以访问任意属性而不报错，前提是你必须确定该对象上存在这个属性4.将 any 断言成具体的类型 类型断言的限制1.联合类型可以被断言成具体类型2.父类型可以被断言成具体的子类型3.任何类型可以被断言成 any 4. any 可以被断言成人意类型typescript是结构类型系统，类型之间的对比只会比较他们最终的结构，而忽略他们定义时的关系。 typescriptinterfaceAnimal name string interfaceCat name string run void lettom Cat name tom ,run console.log run letanimal Animal tom 因为Animal和Cat项目兼容，所以可以使用实现了Cat接口的数据对象给声明为Animal的对象赋值，实际上，Animal和Cat与下面的实现相同 typescriptinterfaceAnimal name string interfaceCatextendsAnimal run void 当 Animal 兼容 Cat 时，他们就可以互相之间进行类型断言。 双重断言 typescriptfooasanyasother 将任意类型断言成 any 再将 any 断言成其他类型，这在ts编译阶段通常不会报错，但是这种做法其实跳过了类型，需要谨慎使用 类型断言和类型转换类型断言只是用于TypeScript编译阶段，实际并不会影响对象的类型，在编译成js时类型断言语句会被删除，类型转换需要使用类型转换语句。 声明文件当使用第三方库时，我们需要引用他的声明文件，才能获得相应的代码补全，接口提示等功能。声明文件必需以 .d.ts 为后缀。 书写声明文件1. declarevar 声明全局变量2. declarefuncton 声明全局方法3. declareclass 声明全局类4. declareenum 声明全局枚举类型5. declarenamespace 声明全局对象6. interface和type 声明全局类型 EMCAScript内置对象 EMCAScript标准的内置对象 Boolean Error Date RegExp 等。更多的内置对象，可以查看 MDN的文档 。而他们的定义文件，则在 TypeScript核心库的定义文件 中。 DOM和BOM内置对象 Document HTMLElement Event NodeList 等。常用 typescriptletbody HTMLElement document.body letallDiv NodeList document.querySelectorAll div document.addEventListener click ,function e MouseEvent Dosomething 类型别名类型别名用来给一个类型取一个新名字 typescripttypeName string typeNameResolver string typeNameOrResolver Name NameResolver functiongetName n NameOrResolver Name if typeofn string returnn else returnn 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个 typescripttypeEventNames click scroll mousemove functionhandleEvent ele Element,event EventNames dosomething 元组数组合并来相同类型的对象，而元组合并了不同类型的对象。 typescriptlettom number,string 1, xxx 越界的元素当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型 typescriptlettom string,number tom Tom ,25 tom.push male tom.push true 编译报错 枚举 简单的枚举定义 typescriptenumDays Sun,Mon,Tue,Wed,Thu,Fri,Sat 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射 typescriptconsole.log Days Sun 0 trueconsole.log Days Mon 1 trueconsole.log Days Tue 2 trueconsole.log Days Sat 6 trueconsole.log Days 0 Sun trueconsole.log Days 1 Mon trueconsole.log Days 2 Tue trueconsole.log Days 6 Sat true 手动赋值我们可以给枚举值手动赋值，值会从手动赋值到数字开始递增，所以要注意覆盖问题。 typescriptenumDays Sun 3,Mon 1,Tue,Wed,Thu,Fri,Sat console.log Days Sun 3 trueconsole.log Days Wed 3 trueconsole.log Days 3 Sun falseconsole.log Days 3 Wed true TypeScript不会检查手动赋值到覆盖问题，所以需要格外注意。手动赋值的枚举项可以不是数字 typescriptenumDays Sun 7,Mon,Tue,Wed,Thu,Fri,Sat any S 手动枚举可以赋值为负数或者小数，后续未手动赋值的项目依然会以 1 为步长递增 typescriptenumDays Sun 7,Mon 1.5,Tue,Wed,Thu,Fri,Sat console.log Days Sun 7 trueconsole.log Days Mon 1.5 trueconsole.log Days Tue 2.5 trueconsole.log Days Sat 6.5 true 常数项和计算所得项枚举项有两种类型， 常数项 和 计算所得项 前面列举的都是常数项，计算所得项如下 typescriptenumColor Red,Green,Blue blue .length 如果在计算所得项后有未手动赋值的枚举项，将会因为无法得到初始值报错 typescriptenumColor Red red .length,Green,Blue index.ts 1,33 errorTS1061 Enummembermusthaveinitializer. index.ts 1,40 errorTS1061 Enummembermusthaveinitializer. 常数枚举常数枚举是使用 constenum 定义的枚举类型 typescriptconstenumDirections Up,Down,Left,Right letdirections Directions.Up,Directions.Down,Directions.Left,Directions.Right 常数枚举和普通枚举的区别是，它会在编译阶段删除，而且不能包括计算成员 外部枚举外部枚举是使用 delareenum 定义的枚举类型 typescriptdeclareenumDirections Up,Down,Left,Right letdirections Directions.Up,Directions.Down,Directions.Left,Directions.Right 外部枚举通常出现在声明语句中。 类传统方法中，使用构造函数创建类，通过原型链实现继承。在ES6中，我们有了class。用法与C 等面向对象语言一致。 补充 Omit3.5版本之后，TypeScript在lib.es5.d.ts里添加了一个Omit T,K 帮助类型。Omit T,K 类型让我们可以从另一个对象类型中剔除某些属性，并创建一个新的对象类型 typescripttypeUser id string name string email string typeUserWithoutEmail Omit User, email 等价于 typeUserWithoutEmail id string name string ","categorie":"前端-TypeScript-基础"},{"route":"/docs/react/最佳实践/从零构建一个React项目.html","content":" 从零构建一个React项目 Start新建文件夹，执行 shellyarninit 安装基础包 shellyarnaddreactreact domyarnaddwebpackwebpack cli 简单编写代码1.添加src文件夹2.在src添加index.js文件3.index.js文件内容 typescriptimportReactDomfrom react dom ReactDom.render xxx ,document.getElementById root 4.添加webpack.config.js配置简单配置webpack typescriptmodule.exports entry . src index.js ,output filename . index.js 5.编辑package.json文件，添加编译命令 typescript scripts build webpack , 6.命令行执行编译命令 shellyarnrunbuild 完成最简版本前端项目，编译出index.js手动创建index.html添加对该js的引用 index.html html html body divid root div scriptsrc . index.js script body html 使用第一个插件简单版需要手动创建html和手动引用资源文件，显然我们并不想这么干，在css，图片，等资源丰富之后，一个个手动新增并不现实，于是我们需要一个插件帮助在build阶段实现自动输出index.html。 使用HtmlWebpackPlugin插件1.安装 shellyarnadd devhtml webpack plugin 2.在src下创建index.html模板文件，内容如下 html html body divid root div body html 3.配置使用 typescriptconstHtmlWebpackPlugin require html webpack plugin module.exports entry . src index.js ,output filename . index.js ,plugins newHtmlWebpackPlugin template . src index.html 4.再次build在dist文件夹可以看到index.js和index.html文件，使用浏览器打开index.html出现如我们所期望的内容。 更近一步简单项目我们使用了ReactDom挂载简单的内容到指定Dom容器中，显然我们实际工作中并不会如此简单，更近一步的，我们需要做到 使用TypeScript 使用JSX 使用webpackdevserver 引用CSS文件 引用静态图片文件 使用JSX1.创建 src app 文件夹，新建 index.js 文件，内容如下 typescriptimport Component from react classIndexextendsComponent render return xxxx exportdefaultIndex 2.在 src index.js 中使用 jsx typescriptimportReactDomfrom react dom importAppfrom . app index ReactDom.render App ,document.getElementById root 3.执行 yarnrunbuild 这时会报错，因为 jsx 作为js的语法扩展，并不被原生js支持，我们需要配置webpack，使用 babel loader 4.安装 yarnadd devbabel loader babel preset react 5.配置webpack.config.js typescriptmodule rules test . ts js tsx ,use loader babel loader ,options presets babel preset react ,exclude node_modules , , , , 6.执行 yarnrunbuild 可以看到成功编译7.打开index.html文件，页面空白，控制台报错 reactisnotdefined 发现编译后没有React库8.修改 src index.js ，添加对React的引用 typescriptimportReactDomfrom react dom importReactfrom react importAppfrom . app index ReactDom.render App ,document.getElementById root 9.修改 src app index.js ，添加对React的引用 typescriptimportReact, Component from react classIndexextendsComponent render return div xxxxxxxxxxx div exportdefaultIndex 10.再次编译后，提示成功，打开html页面，显示正常。 使用TypeScript1.修改 src app index.js 文件名后缀为 index.tsx 2.修改 src app index.tsx 内容为 typescriptimportReact, Component from react interfaceIndexProps name string age number classIndexextendsComponent IndexProps render return div xxxxxxxxxxx div exportdefaultIndex 3.修改 src index.js 文件名后缀为 index.tsx 4.添加插件 yarnadd devtypescriptawesome typescript loadersource map loader 5.修改webpack配置，添加Loader typescript test .tsx ,loader awesome typescript loader , 添加resolve配置，实现webpack对 tsx 后缀文件的识别 typescriptresolve extensions .tsx , .ts , .js , 6.添加 tsconfig.json 配置typescript编译器选项 typescript compilerOptions outDir . dist , sourceMap true, noImplicitAny true, module commonjs , target es5 , esModuleInterop true, jsx react , include src , 注意，不添加esModuleInterop会导致一些没有默认导出的外部模块报错7.执行编译，如期报错，因为我们在使用组件时没有给组件添加属性。8.修改 src index.tsx 文件内容如下 typescriptimportReactDOMfrom react dom importReactfrom react importAppfrom . app index ReactDOM.render Appage 1 name xxx ,document.getElementById root 9.再次执行 yarnrunbuild ，编译成功，打开index.html显示正常。10.对于引入css可能会出现报错，因为没有导出，可以添加 global.d.ts 文件，内容如下 typescriptdeclaremodule .css declaremodule .scss declaremodule .png 11.修改 tsconfig.json 的配置 typescript compilerOptions outDir . dist , sourceMap true, noImplicitAny true, module commonjs , target es5 , esModuleInterop true, jsx react , include src , global.d.ts , 使用webpackdevserver我们使用开发服务器代替打开html文件的方式1.添加包 yarnadd devwebpack dev server 2.在 package.json 添加执行脚本 typescript start webpack dev server 3.配置 webpack.config.js 文件新增 devServer 节点 typescriptdevServer contentBase path.join __dirname, dist ,compress true,port 9000 4.使用命令 yarnstart 启动开发环境。访问 http localhost 9000 看到页面正常显示，修改文件，自动编译和刷新5.这时默认只有localhost的可以访问，如果是在远程机开发，需要如下修改，然后才能使用远程机ip加端口访问 typescriptdevServer host 0.0.0.0 ,contentBase path.join __dirname, dist ,compress true,port 9000 这个配置几乎没有遇到坑点。 引入样式我们需要事项以下目的 1.在组件中使用 import myclassname from .. index.scss 导入和使用样式。2.编译后，生成单独的样式文件步骤 1.新增 src style.scss 样式文件，并编写样式内容如下 typescript.test text align center width 100 2.修改 src app index.tsx 文件，添加引入和使用样式的代码 typescriptimportReact, Component from react importStylesfrom .. style.scss interfaceIndexProps name string age number classIndexextendsComponent IndexProps render return divclassName Styles.test xxxxxxxxxxx div exportdefaultIndex 3.执行 yarnstart 报错，提示没有处理改类型文件的Loader。4.安装Loader yarnadd devcss loadersass loaderstyle loader 5.修改webpack配置文件，添加Loader typescript test .css scss ,use style loader , loader require.resolve css loader ,options modules true, , sass loader 将Sass编译成CSS，默认使用NodeSass 6.执行 yarnstart 提示成功，打开浏览器可以看到文字已居中，但是我们会发现，并没有使用单独的css文件，而是通过js创建的css，这不利于生产上，用户对资源的缓存，比如我们修改的js，但是没有修改样式，最终编译出来的js有变化，客户端会重新加载而不使用缓存，所以我们需要分离js和css。7.安装插件 yarnadd devmini css extract plugin 修改webpack配置，需要修改Loader以及添加插件 替换style loader typescript test .css scss ,use loader MiniCssExtractPlugin.loader,options publicPath .. , loader require.resolve css loader ,options modules true, , sass loader 将Sass编译成CSS，默认使用NodeSass 添加plugins typescriptplugins newHtmlWebpackPlugin template . src index.html ,newMiniCssExtractPlugin filename name .css ,chunkFilename id .css , 注意需要在开头引入插件 constMiniCssExtractPlugin require mini css extract plugin 8.再次执行 yarnstart 页面成功运行，并且在网络请求中可以看到有单独的css文件。坑点 1.当前已经不需要使用 typings for css modules loader 来做在tsx中应用css文件的功能，只需要修改css loader的options添加 modules true 即可 使用静态图片我们希望实现1.图片资源可以在组件中被import2.图片资源可以这样使用 typescriptimportmyimgfrom .. asset test.png .... imgsrc myimg 步骤 1.修改 src app index.tsx 文件，添加图片引用和使用代码 typescriptimportReact, Component from react importStylesfrom .. style.scss importbaiduImgfrom .. asset baidu logo.png interfaceIndexProps name string age number classIndexextendsComponent IndexProps render return divclassName Styles.test imgsrc baiduImg xxxxxxxxxxx div exportdefaultIndex 2.执行 yarnstart 报错，提示无法处理该类型文件。3.添加 file loader typescriptyarnadd devfile loader 4.修改webpack配置，添加Loader typescript loader require.resolve file loader , Exclude js filestokeep css loaderworkingasitinjects itsruntimethatwouldotherwisebeprocessedthrough file loader. Alsoexclude html and json extensionssotheygetprocessed bywebpacksinternalloaders.exclude . js mjs jsx ts tsx css scss , .html , .json ,options name name . hash 12 . ext , , , 5.再次执行 yarnstart 页面正常加载，图片显示。未发现坑点。考虑性能问题，小于8k的图片我们可能不希望浏览器发起http请求去获取，这时我们可以使用 url loader typescript test . gif png svg eot otf ttf woff woff2 ,use loader url loader ,options limit 8192, , 注意，必须配合 file loader 使用，虽然不会报错，但是生产的base64无法被展示为图片。 typescript loader require.resolve file loader ,exclude . js mjs jsx ts tsx css scss svg , .html , .json ,options name name . hash 12 . ext , , , 其他1.开启 sourcemap ，在开发阶段方便调试代码。需修改webpack配置如下 typescriptmodule.exports entry . src index.tsx ,output filename . index.js ,devtool source map ,..... 结束如此我们大致实现了 create react app 帮助实现的基本功能，但是我们观察create帮助创建的项目，会发现，仍然有很多插件和实现我们没有使用到过，在下面的开发中，我们尝试构建一个完整的复杂前端项目，发现问题的同时，理解create中的其他插件和操作。 手撸一个业务系统我们尝试开发一个真实可用的系统，在实践中完善我们的工具链和架构 目标产品 FAQ1.当我们通过NGINX转发时，一般会设定basepath用作转发，这时如果是通过 create react app 创建的react应用，可以修改 package.json 配置 homepage 节点","categorie":"React-最佳实践-从零构建一个React项目"}]